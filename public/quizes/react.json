[
  {
    "id": "1",
    "lang": {
      "en": {
        "topic": "Frontend frameworks",
        "type": {
          "singleAnswer": {
            "question": "What do frontend frameworks enable us to do?",
            "correctAnswer": "They allow us to synchronize the user interface with incoming data in a simpler way than with 'vanilla' JS.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a primary benefit of using frontend frameworks?",
            "correctAnswer": "Maintaining user interfaces synchronized with data more easily than with vanilla JS.",
            "falseAnswers": [
              "Building server-side applications.",
              "Managing databases.",
              "Performing complex mathematical calculations."
            ]
          }
        }
      },
      "hr": {
        "topic": "frontend okviri(frontend frameworks)",
        "type": {
          "singleAnswer": {
            "question": "Šta nam omogućavaju frontend okviri?",
            "correctAnswer": "Omogućuju nam sinkronizaciju korisničkog sučelja s nadolazećim podacima na jednostavniji način nego s vanilla JS-om.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je primarna prednost korištenja frontend okvira?",
            "correctAnswer": "Lakše održavanje korisničkih sučelja sinkroniziranih s podacima nego s vanilla JS-om.",
            "falseAnswers": [
              "Izgradnja aplikacija na strani servera.",
              "Upravljanje bazama podataka.",
              "Izvođenje složenih matematičkih izračuna."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "2",
    "lang": {
      "en": {
        "topic": "React",
        "type": {
          "singleAnswer": {
            "question": "What is the official definition of React?",
            "correctAnswer": "A JavaScript library for building user interfaces.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "According to the official definition, what is React?",
            "correctAnswer": "A JavaScript library for building user interfaces.",
            "falseAnswers": [
              "A full-stack framework.",
              "A server-side language.",
              "A database management system."
            ]
          }
        }
      },
      "hr": {
        "topic": "react",
        "type": {
          "singleAnswer": {
            "question": "Koja je službena definicija React-a?",
            "correctAnswer": "JavaScript biblioteka za izgradnju korisničkog sučelja.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Prema službenoj definiciji, što je React?",
            "correctAnswer": "JavaScript biblioteka za izgradnju korisničkog sučelja.",
            "falseAnswers": [
              "Full-stack framework.",
              "Jezik na strani servera.",
              "Sustav za upravljanje bazama podataka."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "3",
    "lang": {
      "en": {
        "topic": "React",
        "type": {
          "singleAnswer": {
            "question": "Who created React?",
            "correctAnswer": "Facebook.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Which company originally created React?",
            "correctAnswer": "Facebook.",
            "falseAnswers": ["Google.", "Microsoft.", "Apple."]
          }
        }
      },
      "hr": {
        "topic": "react",
        "type": {
          "singleAnswer": {
            "question": "Tko je napravio React?",
            "correctAnswer": "Facebook.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je tvrtka izvorno stvorila React?",
            "correctAnswer": "Facebook.",
            "falseAnswers": ["Google.", "Microsoft.", "Apple."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "4",
    "lang": {
      "en": {
        "topic": "React",
        "type": {
          "singleAnswer": {
            "question": "What is the basic concept of React?",
            "correctAnswer": "We describe how components look and function in a declarative way by using declarative syntax, specifically JSX.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the fundamental concept behind React?",
            "correctAnswer": "Describing UI components using declarative syntax (JSX).",
            "falseAnswers": [
              "Directly manipulating the DOM.",
              "Using imperative programming for UI updates.",
              "Managing application state in a global store only."
            ]
          }
        }
      },
      "hr": {
        "topic": "react",
        "type": {
          "singleAnswer": {
            "question": "Koji je osnovni koncept React-a?",
            "correctAnswer": "Mi opisujemo kako komponente izgledaju i rade na deklarativan način koristeći deklarativnu sintaksu, odnosno JSX.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koji je temeljni koncept iza React-a?",
            "correctAnswer": "Opisivanje UI komponenti korištenjem deklarativne sintakse (JSX).",
            "falseAnswers": [
              "Direktno manipuliranje DOM-om.",
              "Korištenje imperativnog programiranja za ažuriranje UI-ja.",
              "Upravljanje stanjem aplikacije samo u globalnom storeu."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "5",
    "lang": {
      "en": {
        "topic": "React",
        "type": {
          "singleAnswer": {
            "question": "What is meant by saying that React has a declarative approach?",
            "correctAnswer": "We don't directly manipulate the DOM, everything is abstract. We state that we want a change, but not how that change is implemented.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What does the declarative approach in React imply?",
            "correctAnswer": "You describe the desired UI state, and React figures out how to update the DOM.",
            "falseAnswers": [
              "You manually manipulate the DOM to update the UI.",
              "You write step-by-step instructions for UI changes.",
              "UI updates are always synchronous."
            ]
          }
        }
      },
      "hr": {
        "topic": "react",
        "type": {
          "singleAnswer": {
            "question": "Pod šta se misli kada se kaže da React ima deklarativan pristup?",
            "correctAnswer": "Ne diramo DOM, sve je apstraktno. Mi kažemo da želimo promjenu, ali ne i kako se ona realizira.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što podrazumijeva deklarativni pristup u React-u?",
            "correctAnswer": "Opisujete željeno stanje UI-ja, a React shvaća kako ažurirati DOM.",
            "falseAnswers": [
              "Ručno manipulirate DOM-om za ažuriranje UI-ja.",
              "Pišete korak-po-korak upute za promjene UI-ja.",
              "Ažuriranja UI-ja su uvijek sinkrona."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "6",
    "lang": {
      "en": {
        "topic": "Components",
        "type": {
          "singleAnswer": {
            "question": "What does a React application consist of and what do components represent?",
            "correctAnswer": "Components, they represent the building blocks of the user interface in React.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What are the fundamental building blocks of a React application?",
            "correctAnswer": "Components.",
            "falseAnswers": [
              "HTML files.",
              "CSS stylesheets.",
              "JavaScript functions only."
            ]
          }
        }
      },
      "hr": {
        "topic": "komponente(components)",
        "type": {
          "singleAnswer": {
            "question": "Od čega se sastoji React aplikacije i što one točno predstavljaju?",
            "correctAnswer": "Komponenti, one predstavljaju gradivne blokove korisničkog sučelja u React-u.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koji su temeljni gradivni blokovi React aplikacije?",
            "correctAnswer": "Komponente.",
            "falseAnswers": [
              "HTML datoteke.",
              "CSS stil datoteke.",
              "Samo JavaScript funkcije."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "7",
    "lang": {
      "en": {
        "topic": "Components",
        "type": {
          "singleAnswer": {
            "question": "What does a component contain?",
            "correctAnswer": "Data, logic, and appearance (what it remembers, how it works, and how it looks).",
            "isEnumeratable": true,
            "answerItems": ["Data", "Logic", "Appearance"]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is typically contained within a React component?",
            "correctAnswer": "Data, logic, and appearance.",
            "falseAnswers": [
              "Only data and appearance.",
              "Only logic and appearance.",
              "Only data and logic."
            ]
          }
        }
      },
      "hr": {
        "topic": "komponente(components)",
        "type": {
          "singleAnswer": {
            "question": "Što sve sadrži jedan komponenta?",
            "correctAnswer": "Podatke, logiku i izgled (šta pamti, kako radi i kako izgleda).",
            "isEnumeratable": true,
            "answerItems": ["Podatke", "Logiku", "Izgled"]
          },
          "multipleChoiceAnswer": {
            "question": "Koje od sljedećih se tipično nalazi unutar React komponente?",
            "correctAnswer": "Podaci, logika i izgled.",
            "falseAnswers": [
              "Samo podaci i izgled.",
              "Samo logika i izgled.",
              "Samo podaci i logika."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "8",
    "lang": {
      "en": {
        "topic": "Components",
        "type": {
          "singleAnswer": {
            "question": "What are the rules for writing components?",
            "correctAnswer": "1. Component names start with a capital letter, 2. Components must return some 'markup' (most often JSX) or null, 3. They are declared in top-level code.",
            "isEnumeratable": true,
            "answerItems": [
              "Names start with a capital letter",
              "Must return markup (JSX or null)",
              "Declared in top-level code"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is a rule for writing React components?",
            "correctAnswer": "Component names must start with a capital letter.",
            "falseAnswers": [
              "Component names must start with a lowercase letter.",
              "Components must return a string.",
              "Components can be declared inside conditional statements."
            ]
          }
        }
      },
      "hr": {
        "topic": "komponente(components)",
        "type": {
          "singleAnswer": {
            "question": "Koja su pravila kod pisanja komponenti?",
            "correctAnswer": "1. Imena komponenti započinju velikim slovom, 2. Komponente moraju vratiti niki 'markup' (najčešće JSX) ili null vrijednost, 3. Deklariraju se u top-level kodu.",
            "isEnumeratable": true,
            "answerItems": [
              "Imena komponenti započinju velikim slovom",
              "Komponente moraju vratiti neki 'markup' (JSX ili null)",
              "Deklariraju se u top-level kodu"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koje od sljedećih je pravilo za pisanje React komponenti?",
            "correctAnswer": "Imena komponenti moraju započinjati velikim slovom.",
            "falseAnswers": [
              "Imena komponenti moraju započinjati malim slovom.",
              "Komponente moraju vratiti string.",
              "Komponente se mogu deklarirati unutar uvjetnih izraza."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "9",
    "lang": {
      "en": {
        "topic": "Components",
        "type": {
          "singleAnswer": {
            "question": "How can components be created and which method is used almost exclusively today? Also, what we mean when we talk about component?",
            "correctAnswer": "They can be created using functions and classes. Today, they are mostly created using functions. So, when we talk about a component, we mean a function that is named with a capital initial letter and returns some JSX (or null).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Which method is predominantly used to create React components today?",
            "correctAnswer": "Using functions.",
            "falseAnswers": [
              "Using classes.",
              "Using objects.",
              "Using arrays."
            ]
          }
        }
      },
      "hr": {
        "topic": "komponente(components)",
        "type": {
          "singleAnswer": {
            "question": "Kako možemo kreirati komponente i koji način se danas skoro uvijek koristi? Također kada pričamo o komponenti na šta se tu točno misli?",
            "correctAnswer": "Možemo ih kreirati preko funkcija i klasa. Danas se većinski kreiraju preko funkcija. Tako da kada pričamo o komponenti mi mislimo na neku funkciju koja je imenovana velikim početnim slovom i vača neki JSX (ili null).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja se metoda pretežno koristi za kreiranje React komponenti danas?",
            "correctAnswer": "Korištenjem funkcija.",
            "falseAnswers": [
              "Korištenjem klasa.",
              "Korištenjem objekata.",
              "Korištenjem nizova."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "10",
    "lang": {
      "en": {
        "topic": "Component tree",
        "type": {
          "singleAnswer": {
            "question": "What does the component tree display?",
            "correctAnswer": "It displays the hierarchy between components, according to which the graphical interface is built. This is the way we, as developers, organize components to construct the user interface.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What does the React component tree represent?",
            "correctAnswer": "The hierarchical structure of components in the user interface.",
            "falseAnswers": [
              "The order in which components are rendered.",
              "The dependencies between different libraries.",
              "The state of each component."
            ]
          }
        }
      },
      "hr": {
        "topic": "stable komponenti(component tree)",
        "type": {
          "singleAnswer": {
            "question": "Što prikazuje stablo komponenti?",
            "correctAnswer": "Prikazuje hijerarhiju među komponentama prema kojoj se izgrađuje grafičko sučelje. To je način na koji mi, developeri, organiziramo komponente kako bismo izgradili korisničko sučelje.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što predstavlja stablo React komponenti?",
            "correctAnswer": "Hijerarhijsku strukturu komponenti u korisničkom sučelju.",
            "falseAnswers": [
              "Redoslijed renderiranja komponenti.",
              "Ovisnosti između različitih biblioteka.",
              "Stanje svake komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "11",
    "lang": {
      "en": {
        "topic": "Components",
        "type": {
          "singleAnswer": {
            "question": "What must React components return?",
            "correctAnswer": "Some markup (JSX) or null.",
            "isEnumeratable": false,
            "answerItems": ["JSX", "markup"]
          },
          "multipleChoiceAnswer": {
            "question": "What is the required return value of a React component function?",
            "correctAnswer": "Some markup (JSX) or null.",
            "falseAnswers": ["A string.", "An object.", "A number."]
          }
        }
      },
      "hr": {
        "topic": "komponente(components)",
        "type": {
          "singleAnswer": {
            "question": "Što moraju vraćati React komponente?",
            "correctAnswer": "Neki markup (JSX) ili null.",
            "isEnumeratable": false,
            "answerItems": ["JSX", "markup"]
          },
          "multipleChoiceAnswer": {
            "question": "Koji je obavezni povratni tip funkcije React komponente?",
            "correctAnswer": "JSX (ili null).",
            "falseAnswers": ["String.", "Objekt.", "Broj."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "12",
    "lang": {
      "en": {
        "topic": "JSX",
        "type": {
          "singleAnswer": {
            "question": "What is JavaScript XML (JSX)?",
            "correctAnswer": "A declarative syntax that describes how components look and how they function (work).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is JSX (JavaScript XML)?",
            "correctAnswer": "A syntax extension for JavaScript used with React to describe UI.",
            "falseAnswers": [
              "A new programming language for web development.",
              "A database query language.",
              "A method for styling HTML elements."
            ]
          }
        }
      },
      "hr": {
        "topic": "JSX",
        "type": {
          "singleAnswer": {
            "question": "Što je JavaScript XML (JSX)?",
            "correctAnswer": "Deklarativna sintaksa koja opisuje kako komponente izgledaju i kako funkcioniraju (rade).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je JSX (JavaScript XML)?",
            "correctAnswer": "Proširenje sintakse za JavaScript koje se koristi s Reactom za opisivanje UI-ja.",
            "falseAnswers": [
              "Novi programski jezik za web razvoj.",
              "Jezik za upite baze podataka.",
              "Metoda za stiliziranje HTML elemenata."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "13",
    "lang": {
      "en": {
        "topic": "JSX",
        "type": {
          "singleAnswer": {
            "question": "What is each JSX element converted into and describe the process?",
            "correctAnswer": "Each JSX element is converted into JavaScript object via the Babel library, which runs when calling the create-react-app command. The process looks like this: JSX is converted into React.createElement(), which takes three parameters: 1) element type, 2) props, 3) children. The result of this function is a JavaScript object (React element) that React uses to create the virtual DOM.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is JSX converted into during the build process?",
            "correctAnswer": "Calls to `React.createElement()` which return React elements (JavaScript objects).",
            "falseAnswers": [
              "Direct DOM manipulation calls.",
              "Plain HTML strings.",
              "CSS stylesheets."
            ]
          }
        }
      },
      "hr": {
        "topic": "JSX",
        "type": {
          "singleAnswer": {
            "question": "U šta se pretvara svaki JSX element i opiši mi proces kako to izgleda?",
            "correctAnswer": "Svaki JSX element se pretvara u JavaScript objekt preko Babel biblioteke koja se pokreće pri pozivanju komande create-react-app. Proces izgleda ovako: JSX se pretvara u React.createElement(), koja prima tri parametra: 1) tip elementa, 2) props, 3) djecu, rezultat te funkcije je JavaScript objekt (React element) kojega React koristi za stvaranje virtualnog DOM-a.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "U što se JSX pretvara tijekom procesa izgradnje?",
            "correctAnswer": "Pozive `React.createElement()` koji vraćaju React elemente (JavaScript objekte).",
            "falseAnswers": [
              "Direktne pozive za manipulaciju DOM-om.",
              "Obične HTML stringove.",
              "CSS stil datoteke."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "14",
    "lang": {
      "en": {
        "topic": "Styling components",
        "type": {
          "singleAnswer": {
            "question": "Which attribute do we use to add styles to components and why?",
            "correctAnswer": "We use the `className` attribute because the keyword `class` is already reserved in JavaScript (same as `for`, `forHtml`).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Why do we use `className` instead of `class` in React for styling?",
            "correctAnswer": "Because `class` is a reserved keyword in JavaScript.",
            "falseAnswers": [
              "Because `className` has higher specificity.",
              "Because `class` is only used for IDs.",
              "Because `className` is a newer syntax."
            ]
          }
        }
      },
      "hr": {
        "topic": "stiliziranje komponenti",
        "type": {
          "singleAnswer": {
            "question": "Preko kojeg atributa dodajemo stilove na komponente i zašto?",
            "correctAnswer": "Preko atributa className jer je ključna riječ class već rezervirana u JavaScript-u (isto kao i for, forHtml).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Zašto koristimo `className` umjesto `class` u Reactu za stiliziranje?",
            "correctAnswer": "Jer je `class` rezervirana ključna riječ u JavaScript-u.",
            "falseAnswers": [
              "Jer `className` ima veću specifičnost.",
              "Jer se `class` koristi samo za ID-jeve.",
              "Jer je `className` novija sintaksa."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "15",
    "lang": {
      "en": {
        "topic": "Props",
        "type": {
          "singleAnswer": {
            "question": "What are props in the context of React?",
            "correctAnswer": "A way of passing data between components, specifically passing data from a parent component to child components.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the primary purpose of props in React?",
            "correctAnswer": "To pass data from parent components to child components.",
            "falseAnswers": [
              "To manage component state.",
              "To handle events within a component.",
              "To define the structure of a component."
            ]
          }
        }
      },
      "hr": {
        "topic": "props",
        "type": {
          "singleAnswer": {
            "question": "Što su props-ovi u kontekstu React-a?",
            "correctAnswer": "Način prosljeđivanja podataka između komponenti, točnije prosljeđivanje podataka između komponente roditelja prema komponentama djece.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je primarna svrha props-ova u React-u?",
            "correctAnswer": "Prosljeđivanje podataka od roditeljskih komponenti djeci komponentama.",
            "falseAnswers": [
              "Upravljanje stanjem komponente.",
              "Rukovanje događajima unutar komponente.",
              "Definiranje strukture komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "16",
    "lang": {
      "en": {
        "topic": "Props",
        "type": {
          "singleAnswer": {
            "question": "What is specific about props compared to other data sources in a component?",
            "correctAnswer": "They are specific because they come from outside and can only be updated in the parent component (or that is how it should be).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What makes props unique compared to other data sources in a component?",
            "correctAnswer": "They are passed from the parent and should be considered external and immutable within the child.",
            "falseAnswers": [
              "They can be updated directly within the child component.",
              "They are used to manage the component's internal state.",
              "They are only used for styling."
            ]
          }
        }
      },
      "hr": {
        "topic": "props",
        "type": {
          "singleAnswer": {
            "question": "Po čemu su props-ovi specifični u odnosu na ostale izvore podataka u komponenti?",
            "correctAnswer": "Specifični su po tome jer dolaze izvana i mogu biti ažurirani samo u roditeljskoj komponenti (ili tako treba biti).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što čini props-ove jedinstvenima u usporedbi s drugim izvorima podataka u komponenti?",
            "correctAnswer": "Prosljeđuju se od roditelja i unutar djeteta bi se trebali smatrati vanjskima i nepromjenjivima.",
            "falseAnswers": [
              "Mogu se ažurirati direktno unutar djeteta komponente.",
              "Koriste se za upravljanje unutarnjim stanjem komponente.",
              "Koriste se samo za stiliziranje."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "17",
    "lang": {
      "en": {
        "topic": "Props",
        "type": {
          "singleAnswer": {
            "question": "What is the strict rule regarding props?",
            "correctAnswer": "Props are immutable; if we need to change them, we should use state.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the strict rule about modifying props in React?",
            "correctAnswer": "Props should be treated as immutable.",
            "falseAnswers": [
              "Props can be modified directly within the child component.",
              "Props should only be modified in the parent component.",
              "Props can be modified if they are objects or arrays."
            ]
          }
        }
      },
      "hr": {
        "topic": "props",
        "type": {
          "singleAnswer": {
            "question": "Koje je strogo pravilo u kontekstu props-ova?",
            "correctAnswer": "Propsovi su nepromjenjivi, ako ih trebamo mijenjati, onda trebamo koristiti state.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koje je strogo pravilo o mijenjanju props-ova u React-u?",
            "correctAnswer": "Props-ovi bi se trebali tretirati kao nepromjenjivi.",
            "falseAnswers": [
              "Props-ovi se mogu mijenjati direktno unutar djeteta komponente.",
              "Props-ovi bi se trebali mijenjati samo u roditeljskoj komponenti.",
              "Props-ovi se mogu mijenjati ako su objekti ili nizovi."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "18",
    "lang": {
      "en": {
        "topic": "Props",
        "type": {
          "singleAnswer": {
            "question": "What are the two reasons why props are immutable, or why we shouldn't change them?",
            "correctAnswer": "First, if we mutate an object passed as a prop, it will also change in any parent components using that same object, potentially leading to unpredictable behavior. Second, React encourages writing 'pure functions,' which are functions without side effects. This means they don't modify values outside their own scope.",
            "isEnumeratable": true,
            "answerItems": [
              "Changing the prop object affects parent components",
              "React components should be pure functions (no side effects)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Why should you generally not modify props directly in a child component?",
            "correctAnswer": "It can lead to unexpected changes in parent components and violates the principle of pure functions.",
            "falseAnswers": [
              "It will cause a compile-time error.",
              "Props can only be modified using the `useState` hook.",
              "It will automatically trigger a re-render of the entire application."
            ]
          }
        }
      },
      "hr": {
        "topic": "props",
        "type": {
          "singleAnswer": {
            "question": "Koja su dva razloga zašto su props-ovi nepromjenjivi, odnosno ne bi ih smjeli mijenjati?",
            "correctAnswer": "Prvi je taj da kada mijenjamo neki objekt koji je predan kao prop, promjeni će se i u svim roditeljskim funkcijama koje ga koriste što može dovesti do nepredvidivog ponašanja. Drugi razlog je taj što u Reactu poštujemo pravilo, odnosno pišemo 'pure functions', tj. funkcije bez nuspojava (side effects). To znači da funkcije ne mijenjaju vrijednosti koje se nalaze izvan njih samih.",
            "isEnumeratable": true,
            "answerItems": [
              "Promjena props objekta utječe na roditeljske komponente",
              "React komponente trebaju biti čiste funkcije (bez nuspojava)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Zašto općenito ne biste trebali mijenjati props-ove direktno u djetetu komponenti?",
            "correctAnswer": "Može dovesti do neočekivanih promjena u roditeljskim komponentama i krši načelo čistih funkcija.",
            "falseAnswers": [
              "Uzrokovat će grešku u vrijeme kompilacije.",
              "Props-ovi se mogu mijenjati samo korištenjem `useState` hooka.",
              "Automatski će pokrenuti ponovno renderiranje cijele aplikacije."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "19",
    "lang": {
      "en": {
        "topic": "One-way data flow",
        "type": {
          "singleAnswer": {
            "question": "What does one-way data flow mean in React?",
            "correctAnswer": "It means that data transfer only happens from parent to child, not the other way around. Advantages include: predictability, easier understanding, better performance, easier debugging.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is characteristic of React's one-way data flow?",
            "correctAnswer": "Data flows from parent components down to child components.",
            "falseAnswers": [
              "Data can flow freely between any components.",
              "Data flows from child components up to parent components.",
              "Data is always synchronized between components automatically."
            ]
          }
        }
      },
      "hr": {
        "topic": "jednosmjerni tok podataka (ona-way data flow)",
        "type": {
          "singleAnswer": {
            "question": "Što znači jednosmjerni tok podataka (one-way data flow) u React-u?",
            "correctAnswer": "To znači da se prijenost podataka događa samo iz smjera roditelja prema djetetu, ne može obratno. Prednosti toga su: predvidivost, lakše razumijevanje, bolje performanse, lakše nalaženje grešaka.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je karakteristično za jednosmjerni tok podataka u React-u?",
            "correctAnswer": "Podaci teku od roditeljskih komponenti prema djeci komponentama.",
            "falseAnswers": [
              "Podaci mogu slobodno teći između bilo kojih komponenti.",
              "Podaci teku od djece komponenti prema roditeljskim komponentama.",
              "Podaci se uvijek automatski sinkroniziraju između komponenti."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "20",
    "lang": {
      "en": {
        "topic": "React fragment",
        "type": {
          "singleAnswer": {
            "question": "What does a React fragment enable us to do, why does it exist, and what is its syntax?",
            "correctAnswer": "It allows us to group multiple elements without using additional HTML elements. This is necessary because React forces a component to return a single element. Syntax: <></> or <React.Fragment></React.Fragment> (used if a key attribute is needed).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the primary purpose of a React Fragment?",
            "correctAnswer": "To group multiple elements without adding an extra node to the DOM.",
            "falseAnswers": [
              "To define a new reusable component.",
              "To manage component state.",
              "To handle asynchronous operations."
            ]
          }
        }
      },
      "hr": {
        "topic": "react fragment",
        "type": {
          "singleAnswer": {
            "question": "Što nam omogućava React fragment, zašto on postoji, navedi njegovu sintaksu?",
            "correctAnswer": "Omogućava nam grupiranje više elemenata bez korištenja dodatnih HTML elemenata. To je potrebno jer nas React forsira da jedna komponenta vraća jedan element. Sintaksa: <></> ili <React.Fragment></React.Fragment> (koristi se ako je potreban key atribut).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je primarna svrha React Fragmenta?",
            "correctAnswer": "Grupiranje više elemenata bez dodavanja dodatnog čvora u DOM.",
            "falseAnswers": [
              "Definiranje nove komponente za ponovnu upotrebu.",
              "Upravljanje stanjem komponente.",
              "Rukovanje asinkronim operacijama."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "21",
    "lang": {
      "en": {
        "topic": "Events",
        "type": {
          "singleAnswer": {
            "question": "What is used in React for event handling?",
            "correctAnswer": "We use attributes on elements (like onClick) and pass them functions that we want to be executed when an event occurs.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "How are events typically handled in React?",
            "correctAnswer": "By using event handler attributes (like `onClick`) on JSX elements.",
            "falseAnswers": [
              "By using `addEventListener` directly on DOM elements.",
              "By defining event listeners in the component's constructor.",
              "By using the `useEffect` hook for all events."
            ]
          }
        }
      },
      "hr": {
        "topic": "događaji(events)",
        "type": {
          "singleAnswer": {
            "question": "Što koristi u React-u za upravljanje događajima?",
            "correctAnswer": "Koristimo atribute na elemente (poput onClick) i njimva predajemo funkcije koje hoćemo da se izvrše prilikom pojavljivanja nekog događaja.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kako se događaji tipično rukuju u React-u?",
            "correctAnswer": "Korištenjem atributa za rukovanje događajima (poput `onClick`) na JSX elementima.",
            "falseAnswers": [
              "Korištenjem `addEventListener` direktno na DOM elementima.",
              "Definiranjem event listenera u konstruktoru komponente.",
              "Korištenjem `useEffect` hooka za sve događaje."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "22",
    "lang": {
      "en": {
        "topic": "Events",
        "type": {
          "singleAnswer": {
            "question": "Why don't we use `.addEventListener` in React?",
            "correctAnswer": "We don't use them because it's an imperative way of handling events, while in React, we use declarative syntax.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Why is `addEventListener` generally avoided in React components?",
            "correctAnswer": "It is an imperative way of handling events, while React favors a declarative approach.",
            "falseAnswers": [
              "It has poor performance in React.",
              "It is not compatible with JSX.",
              "It can only be used with class components."
            ]
          }
        }
      },
      "hr": {
        "topic": "događaji(events)",
        "type": {
          "singleAnswer": {
            "question": "Zašto ne koristimo .addEventListener u React-u?",
            "correctAnswer": "Ne koristimo ih jer je to imperativni način rukovanja događajima. Dok u React-u koristimo deklarativne sintakse.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Zašto se `addEventListener` općenito izbjegava u React komponentama?",
            "correctAnswer": "To je imperativni način rukovanja događajima, dok React preferira deklarativni pristup.",
            "falseAnswers": [
              "Ima loše performanse u React-u.",
              "Nije kompatibilan s JSX-om.",
              "Može se koristiti samo s klasnim komponentama."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "23",
    "lang": {
      "en": {
        "topic": "State",
        "type": {
          "singleAnswer": {
            "question": "What is state in React?",
            "correctAnswer": "Data that a component holds over time, i.e., the memory of the component.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What does 'state' represent in a React component?",
            "correctAnswer": "Data that a component holds and can change over time.",
            "falseAnswers": [
              "Data passed from a parent component.",
              "A method for performing side effects.",
              "The component's visual appearance."
            ]
          }
        }
      },
      "hr": {
        "topic": "state",
        "type": {
          "singleAnswer": {
            "question": "Što je state u React-u?",
            "correctAnswer": "Podaci koje komponenta drži kroz vrijeme, odnosno svoj životni vijek. Memorija komponente.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što predstavlja 'state' u React komponenti?",
            "correctAnswer": "Podatke koje komponenta drži i koji se mogu mijenjati tijekom vremena.",
            "falseAnswers": [
              "Podaci prosljeđeni od roditeljske komponente.",
              "Metoda za izvođenje nuspojava.",
              "Vizualni izgled komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "24",
    "lang": {
      "en": {
        "topic": "State",
        "type": {
          "singleAnswer": {
            "question": "What does a 'piece of state' represent?",
            "correctAnswer": "It represents one variable in a component that holds some state.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "In React, what is meant by a 'piece of state'?",
            "correctAnswer": "A single variable within a component managed by the state hook.",
            "falseAnswers": [
              "The entire state object of a component.",
              "A prop passed from a parent component.",
              "A function that updates the state."
            ]
          }
        }
      },
      "hr": {
        "topic": "state",
        "type": {
          "singleAnswer": {
            "question": "Što predstavlja 'piece of state'?",
            "correctAnswer": "Predstavlja jednu varijablu u komponenti koja sadrži neki state.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "U React-u, što se podrazumijeva pod 'piece of state'?",
            "correctAnswer": "Jedna varijabla unutar komponente kojom upravlja state hook.",
            "falseAnswers": [
              "Cijeli state objekt komponente.",
              "Prop prosljeđen od roditeljske komponente.",
              "Funkcija koja ažurira state."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "25",
    "lang": {
      "en": {
        "topic": "State",
        "type": {
          "singleAnswer": {
            "question": "What happens when we change or update state?",
            "correctAnswer": "We trigger React to re-render that component.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the primary effect of updating a component's state in React?",
            "correctAnswer": "It triggers a re-render of the component.",
            "falseAnswers": [
              "It immediately updates the DOM.",
              "It changes the component's props.",
              "It stops event propagation."
            ]
          }
        }
      },
      "hr": {
        "topic": "state",
        "type": {
          "singleAnswer": {
            "question": "Što se događa kada mijenjamo ili ažuriramo state?",
            "correctAnswer": "Trigreamo React da ponovno učita tu komponentu.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koji je primarni učinak ažuriranja statea komponente u Reactu?",
            "correctAnswer": "Pokreće ponovno renderiranje komponente.",
            "falseAnswers": [
              "Odmah ažurira DOM.",
              "Mijenja props-ove komponente.",
              "Zaustavlja propagaciju događaja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "26",
    "lang": {
      "en": {
        "topic": "State",
        "type": {
          "singleAnswer": {
            "question": "With what function we create state, what we pass to that function, and what does it return?",
            "correctAnswer": "The state is created using the `useState()` function, into which we pass the initial value of the state. This function returns an array of two elements: the first is the state value itself, while the second is the function to change the state value.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "How do you create state in a functional React component?",
            "correctAnswer": "By calling the `useState()` hook, which returns an array with the state value and an updater function.",
            "falseAnswers": [
              "By declaring a variable with the `var` keyword.",
              "By defining a property in the component's constructor.",
              "By using the `useEffect` hook."
            ]
          }
        }
      },
      "hr": {
        "topic": "state",
        "type": {
          "singleAnswer": {
            "question": "Pomoću koje funkcije kreiramo state, šta predajemo u tu funkciju i šta ona vraća?",
            "correctAnswer": "State se kreira pomoću funkcije useState(), u koju predajemo inicialnu vrijednost state-a. Ta funkcija vraća niz od dva elementa, prvi je sama vrijednost state-a, dok je druga funkcija kojom mijenjamo vrijednost state-a.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kako kreirate state u funkcionalnoj React komponenti?",
            "correctAnswer": "Pozivanjem `useState()` hooka, koji vraća niz s vrijednošću statea i funkcijom za ažuriranje.",
            "falseAnswers": [
              "Deklariranjem varijable s ključnom riječi `var`.",
              "Definiranjem svojstva u konstruktoru komponente.",
              "Korištenjem `useEffect` hooka."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "27",
    "lang": {
      "en": {
        "topic": "State",
        "type": {
          "singleAnswer": {
            "question": "What does the code look like when we want to change the state based on the previous state value?",
            "correctAnswer": "setState(prev => prev + 1).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "How do you update state based on its previous value using the state updater function?",
            "correctAnswer": "By passing a function that receives the previous state and returns the new state.",
            "falseAnswers": [
              "By directly modifying the state variable.",
              "By calling the updater function with the new value directly.",
              "By using the `useMemo` hook."
            ]
          }
        }
      },
      "hr": {
        "topic": "state",
        "type": {
          "singleAnswer": {
            "question": "Kako izgleda kod kada želimo mijenjati state ovisno o prethodnoj vrijednosti state-a?",
            "correctAnswer": "setState(prev => prev + 1).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kako ažurirate state na temelju njegove prethodne vrijednosti koristeći funkciju za ažuriranje statea?",
            "correctAnswer": "Prosljeđivanjem funkcije koja prima prethodni state i vraća novi state.",
            "falseAnswers": [
              "Direktnim mijenjanjem varijable statea.",
              "Pozivanjem funkcije za ažuriranje s novom vrijednošću direktno.",
              "Korištenjem `useMemo` hooka."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "28",
    "lang": {
      "en": {
        "topic": "State",
        "type": {
          "singleAnswer": {
            "question": "What is the rule if we change state based on an existing value and that state is object?",
            "correctAnswer": "We must not change the previous object (previous state), but instead create a new object and use copies of the values from the old object (e.g., setItems(prevItems => [...prevItems, newItem])).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "When updating state that is an object or array based on its previous value, what is the recommended approach?",
            "correctAnswer": "Create a new object or array containing the updated values.",
            "falseAnswers": [
              "Directly modify the existing state object or array.",
              "Use the `Object.freeze()` method.",
              "Use the `JSON.parse(JSON.stringify())` method."
            ]
          }
        }
      },
      "hr": {
        "topic": "state",
        "type": {
          "singleAnswer": {
            "question": "Koje je pravilo ako mijenjamo state prema postojećoj vrijednosti i state je neki objekt?",
            "correctAnswer": "Ne smijemo mijenjati taj prethodni objekt (prethodni state), nego trebamo stvoriti novi objekt i koristiti kopije vrijednosti tog starog objekta (npr. setItems(prevItems => [...prevItems, newItem]))",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Prilikom ažuriranja statea koji je objekt ili niz na temelju njegove prethodne vrijednosti, koji je preporučeni pristup?",
            "correctAnswer": "Kreiranje novog objekta ili niza koji sadrži ažurirane vrijednosti.",
            "falseAnswers": [
              "Direktno mijenjanje postojećeg state objekta ili niza.",
              "Korištenje metode `Object.freeze()`.",
              "Korištenje metode `JSON.parse(JSON.stringify())`."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "29",
    "lang": {
      "en": {
        "topic": "State",
        "type": {
          "singleAnswer": {
            "question": "Where is state (and ref) never changed and why?",
            "correctAnswer": "State is never changed in top-level code because it causes an infinite re-renders of that component (or many of them).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Why should you avoid directly modifying state in the top-level code of a functional component?",
            "correctAnswer": "It will cause an infinite re-rendering loop.",
            "falseAnswers": [
              "It will not update the UI.",
              "It will cause a syntax error.",
              "It is only allowed in class components."
            ]
          }
        }
      },
      "hr": {
        "topic": "state",
        "type": {
          "singleAnswer": {
            "question": "Gdje se state (ni ref) nikada ne mijenja i zašto?",
            "correctAnswer": "State se nikada ne mijenja u top-level kodu jer to izaziva beskonačno re-renderiranje (ponovno učitava) komponente (ili više njih).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Zašto biste trebali izbjegavati direktno mijenjanje statea u top-level kodu funkcionalne komponente?",
            "correctAnswer": "Uzrokovat će beskonačnu petlju ponovnog renderiranja.",
            "falseAnswers": [
              "Neće ažurirati UI.",
              "Uzrokovat će sintaksnu grešku.",
              "Dopušteno je samo u klasnim komponentama."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "30",
    "lang": {
      "en": {
        "topic": "React hooks",
        "type": {
          "singleAnswer": {
            "question": "How do we recognize React hooks and what is the rule for calling them?",
            "correctAnswer": "React hooks start with the word 'use' and calling them is only allowed in top-level code.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a rule for calling React hooks?",
            "correctAnswer": "They must be called at the top level of a functional component or custom hook.",
            "falseAnswers": [
              "They can be called inside loops or conditional statements.",
              "They must be called inside class components.",
              "They must be called before the component's return statement."
            ]
          }
        }
      },
      "hr": {
        "topic": "react hukovi",
        "type": {
          "singleAnswer": {
            "question": "Kako prepoznajemo React hukove i koje je pravilo vrijedi za njih kod pozivanja?",
            "correctAnswer": "React hukovi počinju sa riječ 'use' i njihovo pozivanje je dozvoljeno samo u top-level kodu.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koje je pravilo za pozivanje React hookova?",
            "correctAnswer": "Moraju se pozivati na najvišoj razini funkcionalne komponente ili custom hooka.",
            "falseAnswers": [
              "Mogu se pozivati unutar petlji ili uvjetnih izraza.",
              "Moraju se pozivati unutar klasnih komponenti.",
              "Moraju se pozivati prije return izraza komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "31",
    "lang": {
      "en": {
        "topic": "State",
        "type": {
          "singleAnswer": {
            "question": "When do we use state in components?",
            "correctAnswer": "We use it when we want the component to change dynamically based on data and when we want the component to remember data through re-renders (we don't want every re-render to re-declare and re-initialize some data, preserving values across re-renders).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "When is it appropriate to use state in a React component?",
            "correctAnswer": "When the component needs to manage data that changes over time and affects its rendering.",
            "falseAnswers": [
              "For data that is passed down from a parent component and doesn't change.",
              "For performing side effects like data fetching.",
              "For accessing DOM elements directly."
            ]
          }
        }
      },
      "hr": {
        "topic": "state",
        "type": {
          "singleAnswer": {
            "question": "Kada koristimo state u komponentama?",
            "correctAnswer": "Koristimo kada želimo da se komponenta dinamički mijenja ovisno o podacima i kada želimo da komponenta pamti podatke kroz re-rendere (ne želimo da svako ponovno učitavanje komponente ponovno deklarira i inicijalizira neki podataka, čuvanje vrijednosti kroz re-renderanje).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kada je prikladno koristiti state u React komponenti?",
            "correctAnswer": "Kada komponenta treba upravljati podacima koji se mijenjaju tijekom vremena i utječu na njeno renderiranje.",
            "falseAnswers": [
              "Za podatke koji se prosljeđuju od roditeljske komponente i ne mijenjaju se.",
              "Za izvođenje nuspojava poput dohvaćanja podataka.",
              "Za direktan pristup DOM elementima."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "32",
    "lang": {
      "en": {
        "topic": "Controlled elements",
        "type": {
          "singleAnswer": {
            "question": "What are controlled elements in React, and why did the need for them arise?",
            "correctAnswer": "Controlled elements are form elements whose value is controlled by React state. This is necessary because input elements by default store their state (data) directly in the DOM. React does not want this because it wants all data to be in the React application, not within the DOM.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What are controlled elements in React?",
            "correctAnswer": "Form elements whose values are managed by React state.",
            "falseAnswers": [
              "Elements that are styled using CSS.",
              "Elements that trigger events.",
              "Elements that are hidden from the user."
            ]
          }
        }
      },
      "hr": {
        "topic": "kontrolirani elementi (controlled elements)",
        "type": {
          "singleAnswer": {
            "question": "Što su kontrolirani elementi (controller elements) u React-u, i zbog čega se javila njihova potreba?",
            "correctAnswer": "Kontrolirani elementi su form elementi čija je vrijednost kontrolirana React state-om. To je potrebno jer input elementi po default-u  pamte svoj state (podatke) u samom DOM-u. React to ne želi jer on želi sve podatke imati u React aplikaciji, a ne unutar DOM-a.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što su kontrolirani elementi u React-u?",
            "correctAnswer": "Form elementi čije se vrijednosti upravljaju pomoću React statea.",
            "falseAnswers": [
              "Elementi koji se stiliziraju pomoću CSS-a.",
              "Elementi koji pokreću događaje.",
              "Elementi koji su skriveni od korisnika."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "33",
    "lang": {
      "en": {
        "topic": "Controlled elements",
        "type": {
          "singleAnswer": {
            "question": "List the steps for creating a controlled element?",
            "correctAnswer": "The first step is defining the state. The second step is to use the defined state on the input element we want to control by setting the value of that element to the defined state. The third step is to update the value of the passed state via the onChange event.",
            "isEnumeratable": true,
            "answerItems": [
              "Define the state",
              "Set the input element's value to the state",
              "Update the state using the onChange event"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which step is involved in creating a controlled input element in React?",
            "correctAnswer": "Setting the `value` attribute of the input to a state variable.",
            "falseAnswers": [
              "Using `addEventListener` to listen for input changes.",
              "Directly modifying the DOM element's value.",
              "Using the `useRef` hook to manage the input value."
            ]
          }
        }
      },
      "hr": {
        "topic": "kontrolirani elementi (controlled elements)",
        "type": {
          "singleAnswer": {
            "question": "Navedi korake kreiranja kontroliranog elementa?",
            "correctAnswer": "Prvi je korak definiranje state-a. Drugi je korak iskoristiti definirani state na input elementu koji želimo kontrolirati na način da postavimo vrijednost tog elementa na definirani state. Treći je korak da ažuriramo vrijednost predanog state-a preko onChange događaja (eventa).",
            "isEnumeratable": true,
            "answerItems": [
              "Definiranje statea",
              "Postavljanje vrijednosti input elementa na state",
              "Ažuriranje statea pomoću onChange događaja"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koji korak je uključen u kreiranje kontroliranog input elementa u Reactu?",
            "correctAnswer": "Postavljanje `value` atributa inputa na varijablu statea.",
            "falseAnswers": [
              "Korištenje `addEventListener` za osluškivanje promjena inputa.",
              "Direktno mijenjanje vrijednosti DOM elementa.",
              "Korištenje `useRef` hooka za upravljanje vrijednošću inputa."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "34",
    "lang": {
      "en": {
        "topic": "State management",
        "type": {
          "singleAnswer": {
            "question": "What is state management?",
            "correctAnswer": "Deciding when state is needed, what type of state, where to place it, and how it will flow through the application.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What does 'state management' in React involve?",
            "correctAnswer": "Deciding how state is organized, accessed, and updated throughout the application.",
            "falseAnswers": [
              "Managing the layout of components.",
              "Handling asynchronous operations.",
              "Styling components with CSS."
            ]
          }
        }
      },
      "hr": {
        "topic": "upravljanjem state-om (state management)",
        "type": {
          "singleAnswer": {
            "question": "Što je to state management?",
            "correctAnswer": "Odlučivanje kada je potreban state, koji tip state-a, gdje ga smjestiti, te kako će on putovati kroz aplikaciju.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što uključuje 'state management' u Reactu?",
            "correctAnswer": "Odlučivanje kako je state organiziran, pristupan i ažuriran kroz cijelu aplikaciju.",
            "falseAnswers": [
              "Upravljanje rasporedom komponenti.",
              "Rukovanje asinkronim operacijama.",
              "Stiliziranje komponenti pomoću CSS-a."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "35",
    "lang": {
      "en": {
        "topic": "Local state",
        "type": {
          "singleAnswer": {
            "question": "What is local state?",
            "correctAnswer": "State that is defined and managed within a single component, primarily for its own needs. Values from this local state, as well as functions to update it, can optionally be passed down to its direct child components via props.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is 'local state' in React?",
            "correctAnswer": "State that is managed and used only within a single component and its children.",
            "falseAnswers": [
              "State that is shared across the entire application.",
              "State that is stored in the browser's local storage.",
              "State that is fetched from a remote API."
            ]
          }
        }
      },
      "hr": {
        "topic": "lokalni state (local state)",
        "type": {
          "singleAnswer": {
            "question": "Što je to local state?",
            "correctAnswer": "State koji se definira i njime se upravlja iz jedne komponente, prvenstveno za njene vlastite potrebe. Vrijednosti iz tog lokalnog state-a, kao i funkcije za njegovo ažuriranje, mogu se po potrebi proslijediti njezinim direktnim dječjim komponentama putem props-ova. ",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je 'local state' u Reactu?",
            "correctAnswer": "State kojim se upravlja i koristi samo unutar jedne komponente i njezine djece.",
            "falseAnswers": [
              "State koji se dijeli kroz cijelu aplikaciju.",
              "State koji se pohranjuje u lokalnu pohranu preglednika.",
              "State koji se dohvaća s udaljenog API-ja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "36",
    "lang": {
      "en": {
        "topic": "Global state",
        "type": {
          "singleAnswer": {
            "question": "What is global state?",
            "correctAnswer": "State that is needed in multiple different components throughout the entire application. This state is available in every component within the application.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is 'global state' in React?",
            "correctAnswer": "State that is shared and accessible by multiple components across the application.",
            "falseAnswers": [
              "State that is managed only within a single component.",
              "State that is stored in the component's props.",
              "State that is fetched from a remote API only."
            ]
          }
        }
      },
      "hr": {
        "topic": "globalni state (gloval state)",
        "type": {
          "singleAnswer": {
            "question": "Što je to globalni state?",
            "correctAnswer": "State koji je potreban u više različitih komponenti kroz cijelu aplikaciju. Ovaj state je dostupan u svakoj komponenti unutar aplikacije.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je 'global state' u Reactu?",
            "correctAnswer": "State koji se dijeli i dostupan je višestrukim komponentama diljem aplikacije.",
            "falseAnswers": [
              "State kojim se upravlja samo unutar jedne komponente.",
              "State koji se pohranjuje u props-ove komponente.",
              "State koji se dohvaća samo s udaljenog API-ja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "37",
    "lang": {
      "en": {
        "topic": "Component categories",
        "type": {
          "singleAnswer": {
            "question": "What are the categories of components?",
            "correctAnswer": "Stateless/presentational, stateful, and structural components.",
            "isEnumeratable": true,
            "answerItems": [
              "Stateless/presentational",
              "Stateful",
              "Structural"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is a category of React components?",
            "correctAnswer": "Presentational.",
            "falseAnswers": ["Functional.", "Class-based.", "Hook-based."]
          }
        }
      },
      "hr": {
        "topic": "kategorije komponenti",
        "type": {
          "singleAnswer": {
            "question": "Koje su kategorije komponenti?",
            "correctAnswer": "Stateless/presentational (prezentacijska), stateful i structural komponente.",
            "isEnumeratable": true,
            "answerItems": [
              "Stateless/presentational (prezentacijska)",
              "Stateful",
              "Structural"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koja od sljedećih je kategorija React komponenti?",
            "correctAnswer": "Prezentacijska.",
            "falseAnswers": [
              "Funkcionalna.",
              "Temeljena na klasama.",
              "Temeljena na hookovima."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "38",
    "lang": {
      "en": {
        "topic": "Component categories",
        "type": {
          "singleAnswer": {
            "question": "What is a presentational (stateless/presentational) component?",
            "correctAnswer": "A component that has no state, can receive props, and presents some data. They are mostly small and reusable.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a characteristic of a presentational (stateless) component?",
            "correctAnswer": "It has no state and primarily focuses on displaying data based on props.",
            "falseAnswers": [
              "It manages its own internal state.",
              "It performs side effects like data fetching.",
              "It is responsible for the application's routing."
            ]
          }
        }
      },
      "hr": {
        "topic": "ktegorije komponenti",
        "type": {
          "singleAnswer": {
            "question": "Što je to prezentacijska (stateless/presentational) komponenta?",
            "correctAnswer": "Komponenta koja nema state, mogu primati props-ove i prezentirati neke podatke. Većinski su male i ponovno iskoristive.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je karakteristika prezentacijske (stateless) komponente?",
            "correctAnswer": "Nema state i prvenstveno se fokusira na prikaz podataka na temelju props-ova.",
            "falseAnswers": [
              "Upravlja svojim unutarnjim stateom.",
              "Izvodi nuspojave poput dohvaćanja podataka.",
              "Odgovorna je za rutiranje aplikacije."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "39",
    "lang": {
      "en": {
        "topic": "Component categories",
        "type": {
          "singleAnswer": {
            "question": "What is a stateful component?",
            "correctAnswer": "Components that have state; they can be reusable.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What defines a stateful component?",
            "correctAnswer": "It manages its own internal state.",
            "falseAnswers": [
              "It only receives data through props.",
              "It is used solely for layout purposes.",
              "It has no logic or data."
            ]
          }
        }
      },
      "hr": {
        "topic": "kategorije komponenti",
        "type": {
          "singleAnswer": {
            "question": "Što je to stateful komponenta?",
            "correctAnswer": "Komponente koje imaju state, mogu biti ponovno iskoristive.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što definira stateful komponentu?",
            "correctAnswer": "Upravlja svojim unutarnjim stateom.",
            "falseAnswers": [
              "Prima podatke samo kroz props-ove.",
              "Koristi se isključivo u svrhu layouta.",
              "Nema logiku niti podatke."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "40",
    "lang": {
      "en": {
        "topic": "Component categories",
        "type": {
          "singleAnswer": {
            "question": "What is a structural component?",
            "correctAnswer": "Components that are the product of composing smaller components together and are not reusable.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a characteristic of a structural component?",
            "correctAnswer": "It is composed of smaller components and is typically not reusable.",
            "falseAnswers": [
              "It manages the application's global state.",
              "It performs side effects like data fetching.",
              "It is a small, reusable component with no state."
            ]
          }
        }
      },
      "hr": {
        "topic": "kategorije komponenti",
        "type": {
          "singleAnswer": {
            "question": "Što je structural komponenta?",
            "correctAnswer": "Komponente koje su proizvod komponiranja manjih komponenti zajedno i nisu ponovno iskoristive.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je karakteristika structural komponente?",
            "correctAnswer": "Sastoji se od manjih komponenti i tipično nije za ponovnu upotrebu.",
            "falseAnswers": [
              "Upravlja globalnim stateom aplikacije.",
              "Izvodi nuspojave poput dohvaćanja podataka.",
              "To je mala komponenta za ponovnu upotrebu bez statea."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "41",
    "lang": {
      "en": {
        "topic": "Component composition",
        "type": {
          "singleAnswer": {
            "question": "What is component composition?",
            "correctAnswer": "A technique for combining different components using the 'children' prop. It allows for greater flexibility and solves the problem called 'prop drilling'.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is component composition in React?",
            "correctAnswer": "Combining multiple components to build a larger UI.",
            "falseAnswers": [
              "Dividing a large component into smaller ones.",
              "Managing the state of a component.",
              "Handling events within a component."
            ]
          }
        }
      },
      "hr": {
        "topic": "kompozicija komponenti",
        "type": {
          "singleAnswer": {
            "question": "Što je to kompozicija komponenti?",
            "correctAnswer": "Tehnika kombiniranja različitih komponenti korištenjem 'children' props-a. Ona nam omogućava veću fleksibilnost i rješavanje problema zvanog 'prop drilling'.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je kompozicija komponenti u Reactu?",
            "correctAnswer": "Kombiniranje više komponenti za izgradnju većeg UI-ja.",
            "falseAnswers": [
              "Podjela velike komponente na manje.",
              "Upravljanje stateom komponente.",
              "Rukovanje događajima unutar komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "42",
    "lang": {
      "en": {
        "topic": "Components, instances, and elements",
        "type": {
          "singleAnswer": {
            "question": "List the differences between components, component instances, and React elements?",
            "correctAnswer": "Components are functions (blueprints) that describe a part of the user interface and return a React element, usually via JSX format.\n Component instances are created when we use the components themselves (call component functions) and they represent the physical representation of the component that contains state and props. They have their own lifecycle.\n A React element is the result of calling the React.createElement() function, obtained by translating the JSX syntax returned from the component function. It contains all the necessary data to create a DOM element.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "In React, what is a 'component instance'?",
            "correctAnswer": "The physical representation of a component that contains state and props.",
            "falseAnswers": [
              "The function that defines the component.",
              "The JSX returned by the component.",
              "The DOM element rendered by the component."
            ]
          }
        }
      },
      "hr": {
        "topic": "komponente, instance i elementi",
        "type": {
          "singleAnswer": {
            "question": "Navedi mi razlike između komponenti, instanca komponente i React elemenata?",
            "correctAnswer": "Komponente su funkcije (nacrt) koji opisuje dio korisničkog sučelja i vraća React element, obično preko JSX formata.\n Instanca komponente se kreira kada koristimo same komponente (pozivamo funkcije komponente) i one predstavljaju fizičku reprezentaciju komponente koja sadrži state i props-ove. One same po sebi imaju životni vijek.\n React element je rezultat pozivanja React.createElement() funkcije koje se dobiva prevođenjem JSX sintakse koja se vraća iz funkcije komponente. Ona sadrži sve potrebne podatke za kreiranje DOM elementa.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "U Reactu, što je 'instanca komponente'?",
            "correctAnswer": "Fizička reprezentacija komponente koja sadrži state i props-ove.",
            "falseAnswers": [
              "Funkcija koja definira komponentu.",
              "JSX koji vraća komponenta.",
              "DOM element koji renderira komponenta."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "43",
    "lang": {
      "en": {
        "topic": "Rendering",
        "type": {
          "singleAnswer": {
            "question": "What does rendering NOT mean in the context of React?",
            "correctAnswer": "In React, rendering does not mean updating the DOM or displaying elements on the screen.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "In React, what is NOT included in the 'rendering' process?",
            "correctAnswer": "Directly updating the actual DOM.",
            "falseAnswers": [
              "Calling component functions.",
              "Calculating the changes needed in the UI.",
              "Creating React elements."
            ]
          }
        }
      },
      "hr": {
        "topic": "renderiranje",
        "type": {
          "singleAnswer": {
            "question": "Što NE znači renderiranja u kontekstu React-a?",
            "correctAnswer": "U React-u, renderiranje ne znači ažuriranje DOM-a ili prikazivanje elemenata na ekran.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "U Reactu, što NIJE uključeno u proces 'renderiranja'?",
            "correctAnswer": "Direktno ažuriranje stvarnog DOM-a.",
            "falseAnswers": [
              "Pozivanje funkcija komponenti.",
              "Izračunavanje potrebnih promjena u UI-ju.",
              "Kreiranje React elemenata."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "44",
    "lang": {
      "en": {
        "topic": "Rendering",
        "type": {
          "singleAnswer": {
            "question": "What does rendering mean in the context of React?",
            "correctAnswer": "In React, rendering means re-calling component functions and calculating which DOM elements need to be inserted, deleted, or updated without performing these actions on the actual DOM. This all happens internally within React and does not produce any visual changes.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What does 'rendering' mean in React?",
            "correctAnswer": "Calling component functions to calculate the UI output, without immediately updating the DOM.",
            "falseAnswers": [
              "The process of displaying elements on the screen.",
              "Directly manipulating the DOM based on state changes.",
              "Performing side effects like data fetching."
            ]
          }
        }
      },
      "hr": {
        "topic": "renderiranje",
        "type": {
          "singleAnswer": {
            "question": "Što znači renderiranje u kontekstu React-a?",
            "correctAnswer": "U React-u, renderiranja znači ponovno pozivanje funkcija komponenti i kalkuliranja koji DOM element se treba ubaciti, izbrisati ili ažurirati bez vršenja tih radnji nad DOM-om. To se sve događa interno unutar React-a i ne proizvodi nikakve vizualne promjene.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što znači 'renderiranje' u Reactu?",
            "correctAnswer": "Pozivanje funkcija komponenti za izračunavanje UI izlaza, bez trenutnog ažuriranja DOM-a.",
            "falseAnswers": [
              "Proces prikazivanja elemenata na ekranu.",
              "Direktno manipuliranje DOM-om na temelju promjena statea.",
              "Izvođenje nuspojava poput dohvaćanja podataka."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "45",
    "lang": {
      "en": {
        "topic": "Rendering",
        "type": {
          "singleAnswer": {
            "question": "What causes a component to render?",
            "correctAnswer": "Initial application startup, state update, change in context the component is subscribed to, parent re-rendering.",
            "isEnumeratable": true,
            "answerItems": [
              "Initial application startup",
              "State update",
              "Change in context the component is subscribed to",
              "Parent re-rendering"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following can cause a React component to re-render?",
            "correctAnswer": "An update to its state.",
            "falseAnswers": [
              "A change in a prop that the component does not use.",
              "A change in a sibling component's state.",
              "A change in a child component's state."
            ]
          }
        }
      },
      "hr": {
        "topic": "renderiranje",
        "type": {
          "singleAnswer": {
            "question": "Što sve uzrokuje renderiranje komponente?",
            "correctAnswer": "Inicialno pokretanje aplikacije, ažuriranje state-a, promijena context-a na koji je komponenta preplaćena, re-renderiranje roditelja.",
            "isEnumeratable": true,
            "answerItems": [
              "Inicialno pokretanje aplikacije",
              "Ažuriranje state-a",
              "Promijena context-a na koji je komponenta preplaćena",
              "Re-renderiranje roditelja"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koje od sljedećih može uzrokovati ponovno renderiranje React komponente?",
            "correctAnswer": "Ažuriranje njenog statea.",
            "falseAnswers": [
              "Promjena u propu koji komponenta ne koristi.",
              "Promjena u stateu sestrinske komponente.",
              "Promjena u stateu djeteta komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "46",
    "lang": {
      "en": {
        "topic": "Virtual DOM",
        "type": {
          "singleAnswer": {
            "question": "What is the virtual DOM?",
            "correctAnswer": "A lightweight JavaScript object, or a tree structure, consisting of all React elements obtained from React component instances.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the Virtual DOM in React?",
            "correctAnswer": "A lightweight JavaScript representation of the actual DOM.",
            "falseAnswers": [
              "The actual DOM tree in the browser.",
              "A database for storing component data.",
              "A tool for debugging React applications."
            ]
          }
        }
      },
      "hr": {
        "topic": "virtualni DOM (virtual DOM)",
        "type": {
          "singleAnswer": {
            "question": "Što je virtualni DOM?",
            "correctAnswer": "Lagani JavaScript objekt, odnosno stablasta struktura koja se sastoji od svih React elemenata dobivenih iz instanci React komponenti.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je Virtualni DOM u Reactu?",
            "correctAnswer": "Lagana JavaScript reprezentacija stvarnog DOM-a.",
            "falseAnswers": [
              "Stvarno DOM stablo u pregledniku.",
              "Baza podataka za pohranu podataka komponenti.",
              "Alat za debugiranje React aplikacija."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "47",
    "lang": {
      "en": {
        "topic": "Virtual DOM",
        "type": {
          "singleAnswer": {
            "question": "What is the purpose of the virtual DOM, explain?",
            "correctAnswer": "It is used for performance optimization when updating the user interface. When re-rendering, React does not recreate the entire DOM because that would severely impact performance (most often only a small part of the DOM needs to be updated when some state changes). The virtual DOM is fast and efficient to create and is used by React to detect only the necessary changes that need to be made to the actual DOM to display the changes in the application. This happens in the Reconciliation process.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the main purpose of the Virtual DOM?",
            "correctAnswer": "To optimize UI updates by minimizing direct manipulation of the actual DOM.",
            "falseAnswers": [
              "To store the component's state.",
              "To handle asynchronous operations.",
              "To define the component's structure."
            ]
          }
        }
      },
      "hr": {
        "topic": "virtualni DOM (virtual DOM)",
        "type": {
          "singleAnswer": {
            "question": "Čemu služi virtualni DOM, objasni?",
            "correctAnswer": "Služi za optimizaciju performansi prilikom ažuriranja korisničkog sučelja. Prilikom re-renderiranja React ne kreira cijli DOM iznova jer bi to jako naškodilo performansama (najčešće je potrebno samo mali dio DOM-a da se ažurira kada se neki state promijeni). Virtualni dom je brzo i efikasno kreirati i on se koristi kako bi React otkrio samo nužne promijene koje mora napraviti nad DOM-om kako bi prikazao nastale promjene u aplikaciji. To se događa u procesu Reconciliation-a.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je glavna svrha Virtualnog DOM-a?",
            "correctAnswer": "Optimizacija ažuriranja UI-ja minimiziranjem direktne manipulacije stvarnog DOM-a.",
            "falseAnswers": [
              "Pohrana statea komponente.",
              "Rukovanje asinkronim operacijama.",
              "Definiranje strukture komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "48",
    "lang": {
      "en": {
        "topic": "Virtual DOM",
        "type": {
          "singleAnswer": {
            "question": "What is re-rendered (in the virtual DOM) when the state changes in a component?",
            "correctAnswer": "When a component is re-rendered in the virtual DOM, all its children are also re-rendered in the virtual DOM. However, this does not necessarily mean they will change in the actual DOM due to the process called reconciliation.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "When a component's state changes, what happens in the Virtual DOM?",
            "correctAnswer": "The component and all its children are re-rendered in the Virtual DOM.",
            "falseAnswers": [
              "Only the component itself is re-rendered.",
              "Only the parts of the component that changed are re-rendered.",
              "The entire Virtual DOM is rebuilt from scratch."
            ]
          }
        }
      },
      "hr": {
        "topic": "virutalni DOM (virtual DOM)",
        "type": {
          "singleAnswer": {
            "question": "Šta se re-renderira (u virtualnom DOM-u) prilikom pomjena state-a u nekoj komponenti?",
            "correctAnswer": "Kada se neka komponente re-renderira u virutalnom DOM-u, onda se i sva njena djeca re-renderiraju u virtualnom DOM. No to ne znači nužno da će se promijeniti u samom DOM zbog procesa zvan reconciliation.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kada se state komponente promijeni, što se događa u Virtualnom DOM-u?",
            "correctAnswer": "Komponenta i sva njena djeca se ponovno renderiraju u Virtualnom DOM-u.",
            "falseAnswers": [
              "Samo se komponenta sama ponovno renderira.",
              "Samo se dijelovi komponente koji su se promijenili ponovno renderiraju.",
              "Cijeli Virtualni DOM se ponovno izgrađuje od nule."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "49",
    "lang": {
      "en": {
        "topic": "Reconciliation",
        "type": {
          "singleAnswer": {
            "question": "What is reconciliation?",
            "correctAnswer": "The process of deciding which DOM elements actually need to be changed, added, or removed to reflect the changes that occurred in the application. It returns a list of commands to be performed.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the purpose of Reconciliation in React?",
            "correctAnswer": "To determine the minimal set of changes needed to update the actual DOM to match the Virtual DOM.",
            "falseAnswers": [
              "To create the Virtual DOM from the component tree.",
              "To handle asynchronous operations.",
              "To manage component state."
            ]
          }
        }
      },
      "hr": {
        "topic": "reconciliation",
        "type": {
          "singleAnswer": {
            "question": "Što je reconciliation?",
            "correctAnswer": "Proces u kojem se odlučuje koji DOM elementi zapravo trebaju biti promijenjeni, dodani ili maknuti da odraze promijene koje su se dogodili u aplikaciji. Vraća niz naredbi koji ",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je svrha Reconciliationa u Reactu?",
            "correctAnswer": "Određivanje minimalnog skupa promjena potrebnih za ažuriranje stvarnog DOM-a kako bi odgovarao Virtualnom DOM-u.",
            "falseAnswers": [
              "Kreiranje Virtualnog DOM-a iz stabla komponenti.",
              "Rukovanje asinkronim operacijama.",
              "Upravljanje stateom komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "50",
    "lang": {
      "en": {
        "topic": "Reconciliation",
        "type": {
          "singleAnswer": {
            "question": "How does the reconciliation process work in practice?",
            "correctAnswer": "Using the virtual DOM, changes are made to the current fiber tree, resulting in a new fiber tree (workbench fiber tree). Then, using these two fiber trees, through a process called diffing, a list of changes that need to be made to the DOM is obtained to display the changes made.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Which process is part of React's Reconciliation?",
            "correctAnswer": "Diffing (comparing the old and new Virtual DOM/Fiber trees).",
            "falseAnswers": [
              "Directly modifying the actual DOM.",
              "Executing event handlers.",
              "Fetching data from an API."
            ]
          }
        }
      },
      "hr": {
        "topic": "reconciliation",
        "type": {
          "singleAnswer": {
            "question": "Kako izgleda proces reconciliation-a u praksi?",
            "correctAnswer": " Pomoću virtualnog DOM-a se rade promijene na current fiber stablu iz kojega proizlazi novo fiber stablo (workbench fiber stablo). Onda se pomoću ta dva fiber stabla kroz proces zvan diffing dobije lista promjena koje se moraju učiniti nad DOM-om kako bi se prikazale učinjene promijene.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koji proces je dio Reactovog Reconciliationa?",
            "correctAnswer": "Diffing (usporedba starog i novog Virtualnog DOM-a/Fiber stabla).",
            "falseAnswers": [
              "Direktno mijenjanje stvarnog DOM-a.",
              "Izvršavanje event handlera.",
              "Dohvaćanje podataka s API-ja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "51",
    "lang": {
      "en": {
        "topic": "Reconciliation",
        "type": {
          "singleAnswer": {
            "question": "Who performs the reconciliation process and what is its main characteristic?",
            "correctAnswer": "It is performed by the Reconciler or Fiber (the heart of React), which works with the fiber tree data structure. Its main characteristic is that it is executed asynchronously, allowing the rendering process to be divided into parts and tasks that can be prioritized, paused, reused, or discarded.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a key characteristic of React's Reconciliation process?",
            "correctAnswer": "It is executed asynchronously.",
            "falseAnswers": [
              "It is always executed synchronously.",
              "It directly updates the DOM during execution.",
              "It is performed by the browser's rendering engine."
            ]
          }
        }
      },
      "hr": {
        "topic": "reconciliation",
        "type": {
          "singleAnswer": {
            "question": "Tko izvršava proces reconciliation-a i koja je njegova glavna karakteristika?",
            "correctAnswer": "Izvršava ga Reconciler ili Fiber (srce React-a) koji radi sa strukturom podataka fiber stablo, a njegova glavna karakteristika je da se izvršava asinkrono, to nam omogućava da proces renderiranja bude odvojen u dijelove i zadatke koji mogu biti prioritizirani, pauzirani, ponovno iskoristivi ili odbačeni.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je ključna karakteristika Reactovog procesa Reconciliationa?",
            "correctAnswer": "Izvršava se asinkrono.",
            "falseAnswers": [
              "Uvijek se izvršava sinkrono.",
              "Direktno ažurira DOM tijekom izvršavanja.",
              "Izvodi ga rendering engine preglednika."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "52",
    "lang": {
      "en": {
        "topic": "Fiber tree",
        "type": {
          "singleAnswer": {
            "question": "What is a fiber tree?",
            "correctAnswer": "An internal immutable (created only on the initial render, updated throughout the application's life) data structure (linked list) that contains a fiber for each instance of a DOM element.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a Fiber tree in React?",
            "correctAnswer": "An internal data structure representing the component tree and its state.",
            "falseAnswers": [
              "The actual DOM tree.",
              "A representation of the Virtual DOM.",
              "A list of all event handlers."
            ]
          }
        }
      },
      "hr": {
        "topic": "fiber tree",
        "type": {
          "singleAnswer": {
            "question": "Što je fiber tree?",
            "correctAnswer": "Interna nepromjenjiva (kreira se samo na incialnom renderu, a ažurira se kroz vijek aplikacije) struktura podataka (povezana lista) koja sadrži fiber za svaku instancu DOM elemnta.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je Fiber stablo u Reactu?",
            "correctAnswer": "Interna struktura podataka koja predstavlja stablo komponenti i njihov state.",
            "falseAnswers": [
              "Stvarno DOM stablo.",
              "Reprezentacija Virtualnog DOM-a.",
              "Popis svih event handlera."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "53",
    "lang": {
      "en": {
        "topic": "Fiber",
        "type": {
          "singleAnswer": {
            "question": "What does a fiber represent within the fiber tree?",
            "correctAnswer": "They represent an instance of a DOM element and are not recreated for each render, but are only changed throughout the application's life. For this reason, they store states, props, hooks, side effects, etc.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What does a 'Fiber' represent in React's Fiber tree?",
            "correctAnswer": "An instance of a component or DOM element.",
            "falseAnswers": [
              "A single Virtual DOM node.",
              "A CSS rule.",
              "An event listener."
            ]
          }
        }
      },
      "hr": {
        "topic": "fiber",
        "type": {
          "singleAnswer": {
            "question": "Što predstavlja fiber unutar fiber stabla?",
            "correctAnswer": "Oni predstavljaju instancu DOM elementa i nisu rekreirani za svaki render, nego se samo mijenjaju kroz vijek apliakcije i zbog tog razloga se u njima spremaju state-ovi, props-ovi, hook-ovi, side efekti, itd...",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što predstavlja 'Fiber' u Reactovom Fiber stablu?",
            "correctAnswer": "Instancu komponente ili DOM elementa.",
            "falseAnswers": [
              "Jedan čvor Virtualnog DOM-a.",
              "CSS pravilo.",
              "Event listener."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "54",
    "lang": {
      "en": {
        "topic": "Fiber tree",
        "type": {
          "singleAnswer": {
            "question": "What two fiber trees exist that are important in the rendering process, and what does each represent?",
            "correctAnswer": "There is the current fiber tree, which represents what is currently displayed on the screen, i.e., the tree from the previous successful rendering. The second is the workbench fiber tree, which is created from the rendering phase using the current fiber tree and the virtual DOM. It is used to obtain the list of changes that need to be made to the DOM.",
            "isEnumeratable": true,
            "answerItems": [
              "Current fiber tree (what is currently displayed)",
              "Workbench fiber tree (used to determine changes)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "In React's rendering process, what does the 'current fiber tree' represent?",
            "correctAnswer": "The tree representing what is currently displayed on the screen.",
            "falseAnswers": [
              "The newly generated tree after a state update.",
              "The Virtual DOM tree.",
              "The actual DOM tree."
            ]
          }
        }
      },
      "hr": {
        "topic": "fiber tree",
        "type": {
          "singleAnswer": {
            "question": "Koja dva fiber stabla postoje, a bitna su nam u procesu renderiranja, i navedi šta koje predstavlja?",
            "correctAnswer": "Postoji current fiber stablo koje predstavlja ono što je trenutno prikazano na ekranu, odnosno stablo iz prethodnog uspješnog renderiranja. Drugo je workbench fiber stablo koje se stvara iz faze renderiranja pomoću current fiber stabla i virtualnog doma, pomoću njega dolazimo do liste promjena koje trebamo napraviti nad DOM-om.",
            "isEnumeratable": true,
            "answerItems": [
              "Current fiber stablo (ono što je trenutno prikazano)",
              "Workbench fiber stablo (koristi se za određivanje promjena)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "U procesu renderiranja u Reactu, što predstavlja 'current fiber stablo'?",
            "correctAnswer": "Stablo koje predstavlja ono što je trenutno prikazano na ekranu.",
            "falseAnswers": [
              "Novo generirano stablo nakon ažuriranja statea.",
              "Stablo Virtualnog DOM-a.",
              "Stvarno DOM stablo."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "55",
    "lang": {
      "en": {
        "topic": "Rendering",
        "type": {
          "singleAnswer": {
            "question": "What are the phases of rendering in React and who executes each phase?",
            "correctAnswer": "Render phase, commit phase, and displaying changes in the browser.",
            "isEnumeratable": true,
            "answerItems": [
              "Render phase",
              "Commit phase",
              "Displaying changes in the browser"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is a phase in the React rendering process?",
            "correctAnswer": "Commit phase.",
            "falseAnswers": [
              "Parsing phase.",
              "Compilation phase.",
              "Execution phase."
            ]
          }
        }
      },
      "hr": {
        "topic": "renderiranja",
        "type": {
          "singleAnswer": {
            "question": "Koje su faze renderiranja u React-u i tko svaku pojedinu fazu izvršava?",
            "correctAnswer": "Render faza, commit faza i prikaz promjena u pregledniku.",
            "isEnumeratable": true,
            "answerItems": [
              "Render faza",
              "Commit faza",
              "Prikaz promjena u pregledniku"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koja od sljedećih je faza u procesu renderiranja u Reactu?",
            "correctAnswer": "Commit faza.",
            "falseAnswers": [
              "Faza parsiranja.",
              "Faza kompilacije.",
              "Faza izvršavanja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "56",
    "lang": {
      "en": {
        "topic": "Rendering",
        "type": {
          "singleAnswer": {
            "question": "What do we get as a result of the render phase within rendering in the context of React?",
            "correctAnswer": "We get a list of changes that need to be made to the DOM to display the changes made in the application.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the output of the Render phase in React's rendering process?",
            "correctAnswer": "A list of necessary changes to the DOM.",
            "falseAnswers": [
              "The actual updated DOM.",
              "The component's state.",
              "The Virtual DOM tree."
            ]
          }
        }
      },
      "hr": {
        "topic": "renderiranje",
        "type": {
          "singleAnswer": {
            "question": "Što dobijmo kao rezultat render faze unutar renderiranja u kontekstu React-a?",
            "correctAnswer": "Dobijemo listu promjena koje se trebaju učiniti nad DOM-om kako bi se prikazale nastale promjene u aplikaciji.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je izlaz faze Render u procesu renderiranja u Reactu?",
            "correctAnswer": "Popis potrebnih promjena u DOM-u.",
            "falseAnswers": [
              "Stvarno ažurirani DOM.",
              "State komponente.",
              "Stablo Virtualnog DOM-a."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "57",
    "lang": {
      "en": {
        "topic": "Rendering",
        "type": {
          "singleAnswer": {
            "question": "What is done in the commit phase and what do we get as a result in the context of React?",
            "correctAnswer": "The DOM is changed, elements are inserted, deleted, and updated in the DOM, resulting in an updated DOM tree.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What happens during the Commit phase in React's rendering process?",
            "correctAnswer": "The actual DOM is updated with the calculated changes.",
            "falseAnswers": [
              "Component functions are called.",
              "The Virtual DOM is created.",
              "The list of DOM changes is generated."
            ]
          }
        }
      },
      "hr": {
        "topic": "renderiranje",
        "type": {
          "singleAnswer": {
            "question": "Što se radi u commit fazi i što dobijemo kao rezultat iste u kontekstu React-a?",
            "correctAnswer": "Mijenja se DOM, ubacuje, briše i ažuriraju se elementi u DOM te se dobije ažurirano DOM stablo.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što se događa tijekom faze Commit u procesu renderiranja u Reactu?",
            "correctAnswer": "Stvarni DOM se ažurira s izračunatim promjenama.",
            "falseAnswers": [
              "Pozivaju se funkcije komponenti.",
              "Kreira se Virtualni DOM.",
              "Generira se popis promjena u DOM-u."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "58",
    "lang": {
      "en": {
        "topic": "Rendering",
        "type": {
          "singleAnswer": {
            "question": "Who executes which phase of rendering?",
            "correctAnswer": "The Render phase is executed by the React library, the Commit phase is executed by the ReactDOM library, and the display in the browser itself is executed by the browser.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Which library is responsible for executing the Commit phase in React rendering?",
            "correctAnswer": "ReactDOM.",
            "falseAnswers": ["React.", "Babel.", "Webpack."]
          }
        }
      },
      "hr": {
        "topic": "renderiranje",
        "type": {
          "singleAnswer": {
            "question": "Tko izvršava koju fazu renderiranja?",
            "correctAnswer": "Render fazu izvršava React biblioteka, commit fazu izvršava ReactDOM biblioteka, a prikaz u samom pregledniku se izvršava od strane preglednika.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je biblioteka odgovorna za izvršavanje faze Commit u renderiranju u Reactu?",
            "correctAnswer": "ReactDOM.",
            "falseAnswers": ["React.", "Babel.", "Webpack."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "59",
    "lang": {
      "en": {
        "topic": "Commit phase rendering",
        "type": {
          "singleAnswer": {
            "question": "How is the commit phase executed within rendering and why is it important that it is executed this way?",
            "correctAnswer": "It is executed synchronously; it happens all at once and cannot be interrupted. This is important so that the DOM never displays partial results.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a key characteristic of the Commit phase execution?",
            "correctAnswer": "It is executed synchronously and cannot be interrupted.",
            "falseAnswers": [
              "It is executed asynchronously.",
              "It can be paused and resumed.",
              "It happens before the Render phase."
            ]
          }
        }
      }
    },
    "hr": {
      "topic": "commit faza renderiranja",
      "type": {
        "singleAnswer": {
          "question": "Kako se izvšrava commit faza unutar renderiranja i zašto je to bitno da se tako izvršava?",
          "correctAnswer": "Izvršava se sikrono, događa se odjednom i ne može se je prekinuti. To je bitno kako dom nikada ne bi prikazao djelomične rezultate.",
          "isEnumeratable": false,
          "answerItems": []
        },
        "multipleChoiceAnswer": {
          "question": "Koja je ključna karakteristika izvršavanja faze Commit?",
          "correctAnswer": "Izvršava se sinkrono i ne može se prekinuti.",
          "falseAnswers": [
            "Izvršava se asinkrono.",
            "Može se pauzirati i nastaviti.",
            "Događa se prije faze Render."
          ]
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "60",
    "lang": {
      "en": {
        "topic": "Commit phase rendering",
        "type": {
          "singleAnswer": {
            "question": "What happens to the fiber tree in this phase of rendering?",
            "correctAnswer": "The workbench fiber tree becomes the current fiber tree for the next rendering cycle.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "In the Commit phase, what happens to the Fiber trees?",
            "correctAnswer": "The workbench fiber tree becomes the current fiber tree.",
            "falseAnswers": [
              "The current fiber tree is discarded.",
              "A new fiber tree is created from scratch.",
              "The Virtual DOM is updated."
            ]
          }
        }
      },
      "hr": {
        "topic": "commit faza renderiranja",
        "type": {
          "singleAnswer": {
            "question": "Što se događa sa fiber stablom u ovoj fazi renderiranja?",
            "correctAnswer": "Workbench fiber drvo postaje current fiber drvo za sljedeći krug renderiranja.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "U fazi Commit, što se događa s Fiber stablima?",
            "correctAnswer": "Workbench fiber stablo postaje current fiber stablo.",
            "falseAnswers": [
              "Current fiber stablo se odbacuje.",
              "Novo fiber stablo se stvara od nule.",
              "Ažurira se Virtualni DOM."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "61",
    "lang": {
      "en": {
        "topic": "Diffing",
        "type": {
          "singleAnswer": {
            "question": "What other process is executed along with the reconciliation process in React rendering (render phase)?",
            "correctAnswer": "The Diffing process.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Which process is executed alongside Reconciliation in the Render phase?",
            "correctAnswer": "Diffing.",
            "falseAnswers": ["Batching.", "Hoisting.", "Garbage collection."]
          }
        }
      },
      "hr": {
        "topic": "diffing",
        "type": {
          "singleAnswer": {
            "question": "Koji se još proces izvršava uz proces rekonsilizacije u React renderiranju (render fazi)?",
            "correctAnswer": "Diffing proces.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koji se proces izvršava uz Reconciliation u fazi Render?",
            "correctAnswer": "Diffing.",
            "falseAnswers": ["Batching.", "Hoisting.", "Garbage collection."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "62",
    "lang": {
      "en": {
        "topic": "Diffing",
        "type": {
          "singleAnswer": {
            "question": "What is the diffing process?",
            "correctAnswer": "The process of comparing elements step by step between two renders based on their position in the tree.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the Diffing process in React?",
            "correctAnswer": "Comparing the previous and new Virtual DOM/Fiber trees to identify changes.",
            "falseAnswers": [
              "Creating the Virtual DOM.",
              "Updating the actual DOM.",
              "Handling events."
            ]
          }
        }
      },
      "hr": {
        "topic": "diffing",
        "type": {
          "singleAnswer": {
            "question": "Što je diffing proces?",
            "correctAnswer": "Proces uspoređivanja elemenata korak po korak između dva renderiranja prema njihovoj poziciji u stablu.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je proces Diffing u Reactu?",
            "correctAnswer": "Usporedba prethodnog i novog Virtualnog DOM-a/Fiber stabala radi identifikacije promjena.",
            "falseAnswers": [
              "Kreiranje Virtualnog DOM-a.",
              "Ažuriranje stvarnog DOM-a.",
              "Rukovanje događajima."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "63",
    "lang": {
      "en": {
        "topic": "Diffing",
        "type": {
          "singleAnswer": {
            "question": "What are the two fundamental rules (assumptions) based on which diffing works?",
            "correctAnswer": "The first is that two elements of different types will produce a different tree. The second is that elements with the same key prop remain the same across different renders (if they don't change).",
            "isEnumeratable": true,
            "answerItems": [
              "Elements of different types produce different trees",
              "Elements with the same key prop remain the same across renders (if unchanged)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which rule is a fundamental assumption of React's Diffing algorithm?",
            "correctAnswer": "Elements of different types will produce different trees.",
            "falseAnswers": [
              "Elements with the same content are considered identical.",
              "The order of elements within a list does not matter.",
              "All elements are recreated on every render."
            ]
          }
        }
      },
      "hr": {
        "topic": "diffing",
        "type": {
          "singleAnswer": {
            "question": "Koje su dvije fundamentalna previli (pretpostavke) prema kojima diffing radi?",
            "correctAnswer": "Prva je da dva elementa različitih tipova će proizvesti različito stablo. Drugo je da elementi s istim key prop-om ostaju isti kroz različite rendere (ako se ne mijenjaju).",
            "isEnumeratable": true,
            "answerItems": [
              "Elementi različitih tipova proizvode različita stabla",
              "Elementi s istim key propom ostaju isti kroz rendere (ako se ne mijenjaju)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koje je pravilo temeljna pretpostavka Reactovog algoritma Diffing?",
            "correctAnswer": "Elementi različitih tipova proizvest će različita stabla.",
            "falseAnswers": [
              "Elementi s istim sadržajem smatraju se identičnima.",
              "Redoslijed elemenata unutar liste nije bitan.",
              "Svi elementi se ponovno kreiraju pri svakom renderu."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "64",
    "lang": {
      "en": {
        "topic": "Key prop",
        "type": {
          "singleAnswer": {
            "question": "What does the key prop enable us to do in the diffing process?",
            "correctAnswer": "It allows React to distinguish instances of the same component because React would otherwise view them as the same elements according to the second diffing rule and they would share the same state. In short, the key prop allows us to improve rendering performance by enabling us to avoid recreating the same element unnecessarily in specific cases.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the purpose of the `key` prop when rendering lists in React?",
            "correctAnswer": "To help React efficiently update the UI by uniquely identifying elements in a list.",
            "falseAnswers": [
              "To add CSS styles to list items.",
              "To define the order of elements in a list.",
              "To prevent event propagation in list items."
            ]
          }
        }
      },
      "hr": {
        "topic": "key prop",
        "type": {
          "singleAnswer": {
            "question": "šta nam omogućuje key prop u procesu diffing-a?",
            "correctAnswer": "Omogućuje React-u da razlikuje instance iste komponente jer bi ih React prema drugom pravilu diffing gledao kao iste elemente te bi dijelili sami state. Ukratko key prop nam omogućava poboljšanje performansi u renderiranju jer omogućuje da u specifičnim slučajevima ne rekreiramo isti element koji nema potrebe rekreirati.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je svrha `key` propa pri renderiranju lista u Reactu?",
            "correctAnswer": "Pomoć Reactu u učinkovitom ažuriranju UI-ja jedinstvenom identifikacijom elemenata u listi.",
            "falseAnswers": [
              "Dodavanje CSS stilova elementima liste.",
              "Definiranje redoslijeda elemenata u listi.",
              "Sprječavanje propagacije događaja u elementima liste."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "65",
    "lang": {
      "en": {
        "topic": "Pure components",
        "type": {
          "singleAnswer": {
            "question": "Into which two types of logic can we divide a React component?",
            "correctAnswer": "Render and event (event handler functions) logic.",
            "isEnumeratable": true,
            "answerItems": [
              "Render logic",
              "Event (event handler functions) logic"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "What are the two main types of logic in a React component?",
            "correctAnswer": "Render logic and Event logic.",
            "falseAnswers": [
              "State logic and Prop logic.",
              "UI logic and Data logic.",
              "Component logic and Hook logic."
            ]
          }
        }
      },
      "hr": {
        "topic": "čiste komponente",
        "type": {
          "singleAnswer": {
            "question": "Na koje dvije vrste logike možemo podijeliti React komponentu?",
            "correctAnswer": "Render i event (event handler funkcije) logika.",
            "isEnumeratable": true,
            "answerItems": [
              "Render logika",
              "Event (event handler funkcije) logika"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koje su dvije glavne vrste logike u React komponenti?",
            "correctAnswer": "Render logika i Event logika.",
            "falseAnswers": [
              "State logika i Prop logika.",
              "UI logika i Data logika.",
              "Logika komponente i Logika hooka."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "66",
    "lang": {
      "en": {
        "topic": "Pure components",
        "type": {
          "singleAnswer": {
            "question": "What code belongs to the render logic of a component and what does that code describe?",
            "correctAnswer": "It is the code located in the top-level part of the component and the one that is executed every time the component is rendered. It describes how the component will look.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is characteristic of the Render logic in a React component?",
            "correctAnswer": "It is executed on every render and describes the component's appearance.",
            "falseAnswers": [
              "It is executed in response to events.",
              "It performs side effects.",
              "It is responsible for updating the DOM."
            ]
          }
        }
      },
      "hr": {
        "topic": "čiste komponente",
        "type": {
          "singleAnswer": {
            "question": "Koji kod spada u render logiku komponente i šta taj kod opisuje?",
            "correctAnswer": "To je kod koji se nalazi u top-level dijelu komponente i onaj koji se izvršava svaki put kada je komponenta renderirana, opisuje kako će komponenta izgledati.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je karakteristično za Render logiku u React komponenti?",
            "correctAnswer": "Izvršava se pri svakom renderu i opisuje izgled komponente.",
            "falseAnswers": [
              "Izvršava se kao odgovor na događaje.",
              "Izvodi nuspojave.",
              "Odgovorna je za ažuriranje DOM-a."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "67",
    "lang": {
      "en": {
        "topic": "Pure components",
        "type": {
          "singleAnswer": {
            "question": "The code that belongs to event logic is executed as a consequence of what, and what does that code enable us to do?",
            "correctAnswer": "That code is executed as a consequence of the event that the handler is listening for and allows us to make something happen in the application (updating state, HTTP requests, navigating to another page, DOM manipulation).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What triggers the execution of Event logic in a React component?",
            "correctAnswer": "Events that the event handler is listening for.",
            "falseAnswers": [
              "Every time the component is rendered.",
              "When the component is first mounted.",
              "When the component's props change."
            ]
          }
        }
      },
      "hr": {
        "topic": "čiste komponente",
        "type": {
          "singleAnswer": {
            "question": "Kod koji spada u event logika se izvršava kao posljedica čega i šta nam taj kod omogućava?",
            "correctAnswer": "Taj kod se izvršava kao spoljedica događaja koji handler osluškuje i omogućava nam da se nešto događa u aplikaciji (ažuriranje state-a, HTTP zahtjevi, navigacija na drugu stranicu, DOM manipulacija).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što pokreće izvršavanje Event logike u React komponenti?",
            "correctAnswer": "Događaji koje event handler osluškuje.",
            "falseAnswers": [
              "Svaki put kada se komponenta renderira.",
              "Kada se komponenta prvi put mounta.",
              "Kada se promijene props-ovi komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "68",
    "lang": {
      "en": {
        "topic": "Functional programming principles",
        "type": {
          "singleAnswer": {
            "question": "What are the principles of functional programming?",
            "correctAnswer": "Side effects and pure functions.",
            "isEnumeratable": true,
            "answerItems": ["Side effects", "Pure functions"]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is a principle of functional programming?",
            "correctAnswer": "Pure functions.",
            "falseAnswers": [
              "Mutable state.",
              "Imperative programming.",
              "Class-based inheritance."
            ]
          }
        }
      },
      "hr": {
        "topic": "principi funkcionalnog programiranja",
        "type": {
          "singleAnswer": {
            "question": "Koji su principi funkcionalnog programiranja?",
            "correctAnswer": "Nuspojave i čiste funkcije.",
            "isEnumeratable": true,
            "answerItems": ["Nuspojave", "Čiste funkcije"]
          },
          "multipleChoiceAnswer": {
            "question": "Koje od sljedećih je načelo funkcionalnog programiranja?",
            "correctAnswer": "Čiste funkcije.",
            "falseAnswers": [
              "Promjenjivi state.",
              "Imperativno programiranje.",
              "Nasljeđivanje temeljeno na klasama."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "69",
    "lang": {
      "en": {
        "topic": "Functional programming principles",
        "type": {
          "singleAnswer": {
            "question": "What are side effects in the context of functional programming?",
            "correctAnswer": "A side effect is when a function has a dependency on or modifies data that is outside the function's scope.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a 'side effect' in functional programming?",
            "correctAnswer": "A function interacting with the outside world or modifying state outside its scope.",
            "falseAnswers": [
              "A function that returns a value.",
              "A function that takes arguments.",
              "A function that calls another function."
            ]
          }
        }
      },
      "hr": {
        "topic": "principi funkcionalnog programiranja",
        "type": {
          "singleAnswer": {
            "question": "Što su to nuspojave u kontekstu funkcionalnog programiranja?",
            "correctAnswer": "Nuspojava je kada funkcija ima ovisnost o ili izmjenu podataka koji se nalaze izvan dosega funkcije. ",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je 'nuspojava' u funkcionalnom programiranju?",
            "correctAnswer": "Funkcija koja interaktira s vanjskim svijetom ili mijenja state izvan svog opsega.",
            "falseAnswers": [
              "Funkcija koja vraća vrijednost.",
              "Funkcija koja prima argumente.",
              "Funkcija koja poziva drugu funkciju."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "70",
    "lang": {
      "en": {
        "topic": "Functional programming principles",
        "type": {
          "singleAnswer": {
            "question": "What is meant when we say a function depends on data outside its scope when talking about side effects?",
            "correctAnswer": "It means that the function reads or uses data that is not passed as arguments or defined within the function itself.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "When discussing side effects, what does it mean for a function to depend on data outside its scope?",
            "correctAnswer": "The function reads or uses data that is not passed as arguments or defined locally.",
            "falseAnswers": [
              "The function modifies data outside its scope.",
              "The function calls another function defined outside its scope.",
              "The function returns a value that is used outside its scope."
            ]
          }
        }
      },
      "hr": {
        "topic": "principi funkcionalnog programiranja",
        "type": {
          "singleAnswer": {
            "question": "Na šta se misli kada kažemo da funkcija ovisi o podacima izvan njenog dosega kada pričamo o nuspojavama?",
            "correctAnswer": "Tu se misli da funkcija čita ili koristi podatke koji nisu proslijeđeni kao argumenti niti su definirani unutar same funkcije.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kada se raspravlja o nuspojavama, što znači da funkcija ovisi o podacima izvan svog opsega?",
            "correctAnswer": "Funkcija čita ili koristi podatke koji nisu prosljeđeni kao argumenti ili definirani lokalno.",
            "falseAnswers": [
              "Funkcija mijenja podatke izvan svog opsega.",
              "Funkcija poziva drugu funkciju definiranu izvan svog opsega.",
              "Funkcija vraća vrijednost koja se koristi izvan njenog opsega."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "71",
    "lang": {
      "en": {
        "topic": "Functional programming principles",
        "type": {
          "singleAnswer": {
            "question": "What are pure functions?",
            "correctAnswer": "Functions that do not cause any side effects.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What defines a 'pure function'?",
            "correctAnswer": "It always returns the same output for the same input and has no side effects.",
            "falseAnswers": [
              "It can modify data outside its scope.",
              "Its output depends on external state.",
              "It is used for handling asynchronous operations."
            ]
          }
        }
      },
      "hr": {
        "topic": "principi funkcionalnog programiranja",
        "type": {
          "singleAnswer": {
            "question": "Što su to čiste funkcije (pure functions)?",
            "correctAnswer": "Funkcije koje ne prouzrokuju nikakve nuspojave.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što definira 'čistu funkciju'?",
            "correctAnswer": "Uvijek vraća isti izlaz za isti ulaz i nema nuspojava.",
            "falseAnswers": [
              "Može mijenjati podatke izvan svog opsega.",
              "Njen izlaz ovisi o vanjskom stateu.",
              "Koristi se za rukovanje asinkronim operacijama."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "72",
    "lang": {
      "en": {
        "topic": "Rules for render logic",
        "type": {
          "singleAnswer": {
            "question": "How must the render logic in components be?",
            "correctAnswer": "Render logic must not cause any side effects (interact with the outside world); components must be pure. When given the same props, component instances must return the same JSX output.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a key rule for Render logic in React components?",
            "correctAnswer": "It must be pure, without side effects.",
            "falseAnswers": [
              "It must include API calls.",
              "It must update the component's state.",
              "It must directly manipulate the DOM."
            ]
          }
        }
      },
      "hr": {
        "topic": "pravila za render logiku",
        "type": {
          "singleAnswer": {
            "question": "Kakva mora biti render logika u komponetama?",
            "correctAnswer": "Render logika ne smije prouzročiti nikakve nuspojave (imati interakciju s vanjskim svijetom), komponente moraju biti čiste. Kada damo iste props-ove, instance komponente moraju vratiti isti JSX izlaz.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koje je ključno pravilo za Render logiku u React komponentama?",
            "correctAnswer": "Mora biti čista, bez nuspojava.",
            "falseAnswers": [
              "Mora uključivati API pozive.",
              "Mora ažurirati state komponente.",
              "Mora direktno manipulirati DOM-om."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "73",
    "lang": {
      "en": {
        "topic": "Rules for render logic",
        "type": {
          "singleAnswer": {
            "question": "List some things we should not do in render logic?",
            "correctAnswer": "Include API calls, start timers, change objects and variables outside the function (this is why we cannot change props), update state, etc.",
            "isEnumeratable": true,
            "answerItems": [
              "Include API calls",
              "Start timers",
              "Change objects/variables outside the function",
              "Update state"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following should NOT be done in the render logic of a React component?",
            "correctAnswer": "Making an API call.",
            "falseAnswers": [
              "Calculating a value based on props.",
              "Returning JSX.",
              "Mapping over an array to render a list."
            ]
          }
        }
      },
      "hr": {
        "topic": "pravila za render logiku",
        "type": {
          "singleAnswer": {
            "question": "Nabroji neke stvari koje ne smijemo raditi u render logici?",
            "correctAnswer": "Sadržavati API poziva, započinjanje timer-a, mijenja objekte i varijable koje se nalaze izvan funkcije (to je razlog zašto ne možemo mijenjati props-ove), ažurirati state, itd...",
            "isEnumeratable": true,
            "answerItems": [
              "Sadržavati API poziva",
              "Započinjanje timer-a",
              "Mijenja objekte i varijable koje se nalaze izvan funkcije",
              "Ažurirati state"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koje od sljedećih NE bi trebalo raditi u render logici React komponente?",
            "correctAnswer": "Izvođenje API poziva.",
            "falseAnswers": [
              "Izračunavanje vrijednosti na temelju props-ova.",
              "Vraćanje JSX-a.",
              "Mapiranje preko niza za renderiranje liste."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "74",
    "lang": {
      "en": {
        "topic": "Rules for render logic",
        "type": {
          "singleAnswer": {
            "question": "Are side effects bad then?",
            "correctAnswer": "Side effects are not bad in themselves; a program can only be useful if it has some interaction with the outside world. We are the ones who need to know where and when to place them.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Are side effects inherently bad in React?",
            "correctAnswer": "No, they are necessary for interaction with the outside world, but must be managed correctly.",
            "falseAnswers": [
              "Yes, they should always be avoided.",
              "Yes, they always cause performance issues.",
              "Yes, they are only allowed in class components."
            ]
          }
        }
      },
      "hr": {
        "topic": "pravila za render logiku",
        "type": {
          "singleAnswer": {
            "question": "Dali su onda nuspojave loše?",
            "correctAnswer": "Nuspojave nisu loše same po sebi, program jedino može biti koristan ako ima neke interakcije s vanjskim svijetom. Mi smo ti koji trebamo znati gdje i kada ih trebamo smjestiti.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Jesu li nuspojave same po sebi loše u Reactu?",
            "correctAnswer": "Ne, potrebne su za interakciju s vanjskim svijetom, ali se moraju pravilno upravljati.",
            "falseAnswers": [
              "Da, uvijek ih treba izbjegavati.",
              "Da, uvijek uzrokuju probleme s performansama.",
              "Da, dopuštene su samo u klasnim komponentama."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "75",
    "lang": {
      "en": {
        "topic": "Rules for render logic",
        "type": {
          "singleAnswer": {
            "question": "If we want to have side effects, where must we place them?",
            "correctAnswer": "We must place them in event handler functions or special hooks like the useEffect hook.",
            "isEnumeratable": true,
            "answerItems": [
              "Event handler functions",
              "Special hooks like useEffect hook"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Where should side effects be placed in React?",
            "correctAnswer": "In event handlers or `useEffect` hooks.",
            "falseAnswers": [
              "Directly in the component's render logic.",
              "In the component's constructor.",
              "In the component's return statement."
            ]
          }
        }
      },
      "hr": {
        "topic": "pravila render logike",
        "type": {
          "singleAnswer": {
            "question": "Ako hoćemo imati nuspojave gdje is moramo smjestiti?",
            "correctAnswer": "Moramo ih smjestiti u event handler funkcije ili specialne hook-ove poput useEffect hooka.",
            "isEnumeratable": true,
            "answerItems": [
              "event handler funkcije",
              "specialne hook-ove poput useEffect hooka"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Gdje bi se nuspojave trebale smjestiti u Reactu?",
            "correctAnswer": "U event handlere ili `useEffect` hookove.",
            "falseAnswers": [
              "Direktno u render logiku komponente.",
              "U konstruktor komponente.",
              "U return izraz komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "76",
    "lang": {
      "en": {
        "topic": "Batching",
        "type": {
          "singleAnswer": {
            "question": "What is batching in the context of React?",
            "correctAnswer": "The process where, when we have multiple state updates within a function (event handler function or within a hook), React groups them into a single render.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is 'batching' in React?",
            "correctAnswer": "Grouping multiple state updates into a single re-render for performance.",
            "falseAnswers": [
              "Executing multiple asynchronous operations in parallel.",
              "Combining multiple components into one.",
              "Dividing a large task into smaller ones."
            ]
          }
        }
      },
      "hr": {
        "topic": "batching",
        "type": {
          "singleAnswer": {
            "question": "Što je to batching u kontekstu React-a?",
            "correctAnswer": "Proces u kojem kada imamo više ažuriranja nekih state-ova unutar neke funkcije (even handler funkcija ili unutar hook-a), React ih objedinjuje u jedno renderiranje.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je 'batching' u Reactu?",
            "correctAnswer": "Grupiranje višestrukih ažuriranja statea u jedno ponovno renderiranje radi performansi.",
            "falseAnswers": [
              "Izvršavanje više asinkronih operacija paralelno.",
              "Kombiniranje više komponenti u jednu.",
              "Podjela velikog zadatka na manje."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "77",
    "lang": {
      "en": {
        "topic": "Batching",
        "type": {
          "singleAnswer": {
            "question": "How is state updating executed?",
            "correctAnswer": "It is executed asynchronously, and we don't get the updated value immediately after that line; it is only available in the next render.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "How are state updates typically executed in React?",
            "correctAnswer": "Asynchronously.",
            "falseAnswers": [
              "Synchronously.",
              "In parallel.",
              "Only during the commit phase."
            ]
          }
        }
      },
      "hr": {
        "topic": "batching",
        "type": {
          "singleAnswer": {
            "question": "Kako se izvršava ažuriranje state-a?",
            "correctAnswer": "Izvršava se asinkrono i ne dobijemo odmah ažuriranu vrijednost nakon te linije, nego je tek dostupna u novom renderiranju.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kako se tipično izvršavaju ažuriranja statea u Reactu?",
            "correctAnswer": "Asinkrono.",
            "falseAnswers": [
              "Sinkrono.",
              "Paralelno.",
              "Samo tijekom faze commit."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "78",
    "lang": {
      "en": {
        "topic": "Batching",
        "type": {
          "singleAnswer": {
            "question": "In which version did batching become available everywhere and where was it only available before?",
            "correctAnswer": "In React version 18, it became available everywhere (event handlers, promises, timeouts, async functions, native event handlers, API calls and their callbacks), whereas in previous versions, it was only available in event handlers (onClick, onChange, etc.).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "In which React version did automatic batching become available for updates outside of event handlers?",
            "correctAnswer": "React 18.",
            "falseAnswers": ["React 16.", "React 17.", "React 19."]
          }
        }
      },
      "hr": {
        "topic": "batching",
        "type": {
          "singleAnswer": {
            "question": "U kojoj verziji se doša batching svugdje i gdje je prije bio samo dostupan?",
            "correctAnswer": "U React 18 verziji je došo svugdje (event handleri, promise-i, timout-i, asinkrone funkcije, native event handleri, API pozivi i njihvoi callback-ovi), dok je u prijašnjim verzijama samo bio u even handlerima (onClick, onChange, itd...).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "U kojoj je verziji Reacta automatsko batching postalo dostupno za ažuriranja izvan event handlera?",
            "correctAnswer": "React 18.",
            "falseAnswers": ["React 16.", "React 17.", "React 19."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "79",
    "lang": {
      "en": {
        "topic": "Batching",
        "type": {
          "singleAnswer": {
            "question": "How can we write code over which we do not want automatic batching to apply?",
            "correctAnswer": "We put the code inside ReactDOM.flushSync().",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Which method can be used to opt out of automatic batching for state updates?",
            "correctAnswer": "ReactDOM.flushSync().",
            "falseAnswers": [
              "React.unbatch().",
              "useEffect().",
              "useCallback()."
            ]
          }
        }
      },
      "hr": {
        "topic": "batching",
        "type": {
          "singleAnswer": {
            "question": "Kako možemo pisati kod nad kojem ne želimo automatsku primjenu batching-a?",
            "correctAnswer": "Kod stavimo u ReactDOM.flushSync().",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja se metoda može koristiti za isključivanje automatskog batchinga za ažuriranja statea?",
            "correctAnswer": "ReactDOM.flushSync().",
            "falseAnswers": [
              "React.unbatch().",
              "useEffect().",
              "useCallback()."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "80",
    "lang": {
      "en": {
        "topic": "Events in React",
        "type": {
          "singleAnswer": {
            "question": "What is event delegation, and what does it enable?",
            "correctAnswer": "Managing events for multiple elements in a central location, i.e., in a common parent. It enables better performance in some cases.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is event delegation in React?",
            "correctAnswer": "Handling events for multiple child elements using a single event listener on a parent element.",
            "falseAnswers": [
              "Preventing the default behavior of an event.",
              "Stopping event propagation.",
              "Creating custom events."
            ]
          }
        }
      },
      "hr": {
        "topic": "događaji u react-u",
        "type": {
          "singleAnswer": {
            "question": "Što je to event delegacija, i što ona omogućava?",
            "correctAnswer": "Upravljanje događajima za više elemenata u centralnom mjestu, odnosno u zajedničkom roditelju. Omogućava bolje performanse u nekim slučajevim.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je event delegacija u Reactu?",
            "correctAnswer": "Rukovanje događajima za više dječjih elemenata pomoću jednog event listenera na roditeljskom elementu.",
            "falseAnswers": [
              "Sprječavanje zadanog ponašanja događaja.",
              "Zaustavljanje propagacije događaja.",
              "Kreiranje prilagođenih događaja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "81",
    "lang": {
      "en": {
        "topic": "Events in React",
        "type": {
          "singleAnswer": {
            "question": "How does event registration work in React?",
            "correctAnswer": "React registers all event handlers on a single DOM element with the ID 'root'. Specifically, it registers one event handling function for each event type (one event handler function for each event type). For example, if we have multiple onClick functions, it will bundle them all into one and register that single function for the onClick event on the DOM element with the ID 'root' (the root of our application).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Where does React typically attach event listeners in the DOM?",
            "correctAnswer": "On the root DOM element of the application.",
            "falseAnswers": [
              "On each individual DOM element.",
              "On the `<body>` element.",
              "On the `<html>` element."
            ]
          }
        }
      },
      "hr": {
        "topic": "događaji u react-u",
        "type": {
          "singleAnswer": {
            "question": "Kako funkcioniranje registriranje događaja u React-u?",
            "correctAnswer": "React registrira sve event handler-e . na jednom DOM elementu sa id-jem root. Točnije on registrira jednu funkciju za rukovanje događajima za svaki tip događaja (jedan event handler funkcija za svaki tip event-a). Ako imamo npr. više onClick funkcija, on će ih sve zapakirati u jednu i registirirati će tu jednu funkciju na taj onClick događaj na taj DOM element sa id-jem root (root naše aplikacije).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Gdje React tipično priključuje event listenere u DOM-u?",
            "correctAnswer": "Na root DOM elementu aplikacije.",
            "falseAnswers": [
              "Na svakom pojedinačnom DOM elementu.",
              "Na `<body>` elementu.",
              "Na `<html>` elementu."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "82",
    "lang": {
      "en": {
        "topic": "Events in React",
        "type": {
          "singleAnswer": {
            "question": "What does a synthetic event represent?",
            "correctAnswer": "It represents a regular DOM event (object) wrapped in a cross-browser wrapper. This is React's abstraction that standardizes events across different browsers, ensuring consistent behavior regardless of the browser used.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a Synthetic Event in React?",
            "correctAnswer": "A cross-browser wrapper around the browser's native event.",
            "falseAnswers": [
              "A custom event created by the developer.",
              "An event that is triggered programmatically.",
              "An event that is not part of the standard DOM events."
            ]
          }
        }
      },
      "hr": {
        "topic": "događaji u react-u",
        "type": {
          "singleAnswer": {
            "question": "Što predstavlja sintetički događaj?",
            "correctAnswer": "Predstavlja običan DOM događaj (objekt) omotan cross-browser wrapper-om. To je React-ova apstrakcija koja standardizira događaje preko različitih pregldenika, osiguravajući konzistentno ponašanje bez obzira na preglednik koji se koristi.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je Sintetički Događaj u Reactu?",
            "correctAnswer": "Cross-browser wrapper oko nativnog događaja preglednika.",
            "falseAnswers": [
              "Prilagođeni događaj koji je kreirao programer.",
              "Događaj koji se pokreće programski.",
              "Događaj koji nije dio standardnih DOM događaja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "83",
    "lang": {
      "en": {
        "topic": "Component lifecycle",
        "type": {
          "singleAnswer": {
            "question": "What does the component lifecycle represent?",
            "correctAnswer": "It represents the different phases that a component can go through over time.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What does the component lifecycle in React describe?",
            "correctAnswer": "The different phases a component goes through from creation to destruction.",
            "falseAnswers": [
              "The process of passing props.",
              "The method for updating state.",
              "The way events are handled."
            ]
          }
        }
      },
      "hr": {
        "topic": "životni vijek komponente",
        "type": {
          "singleAnswer": {
            "question": "Šta predstavlja životni vijek komponente?",
            "correctAnswer": "Predstavlja različite faze kroz koje komponenta može proći kroz neko vrijeme.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što opisuje životni vijek komponente u Reactu?",
            "correctAnswer": "Različite faze kroz koje komponenta prolazi od kreiranja do uništenja.",
            "falseAnswers": [
              "Proces prosljeđivanja props-ova.",
              "Metodu ažuriranja statea.",
              "Način rukovanja događajima."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "84",
    "lang": {
      "en": {
        "topic": "Component lifecycle",
        "type": {
          "singleAnswer": {
            "question": "Through which phases does a component go and describe what each phase represents?",
            "correctAnswer": "1. Mount: the component is loaded for the first time. 2. Re-render: re-loading the component due to state, props, parent, or context changes (can be in this phase an unlimited number of times). 3. Unmount: the component is no longer needed and is removed from the UI.",
            "isEnumeratable": true,
            "answerItems": [
              "Mount (initial load)",
              "Re-render (due to changes)",
              "Unmount (removed from UI)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is a phase in the React component lifecycle?",
            "correctAnswer": "Unmount.",
            "falseAnswers": ["Creation.", "Execution.", "Compilation."]
          }
        }
      },
      "hr": {
        "topic": "životni vijek komponente",
        "type": {
          "singleAnswer": {
            "question": "Kroz koje faze komponenta prolazi i opiša šta pojedina faza predstavlja?",
            "correctAnswer": "1. Mount: komponenta je učitana po prvi put 2. Re-render: ponovno učitavanje komponente zbog promijene state-a, porps-a, roditelja ili context-a (neograničen broj puta može biti u ovoj fazi) 3. Unmount: komponenta nije više potrebna i uklanja se s UI-a.",
            "isEnumeratable": true,
            "answerItems": [
              "Mount (početno učitavanje)",
              "Re-render (zbog promjena)",
              "Unmount (uklonjena s UI-ja)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koja od sljedećih je faza u životnom ciklusu React komponente?",
            "correctAnswer": "Unmount.",
            "falseAnswers": ["Kreiranje.", "Izvršavanje.", "Kompilacija."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "85",
    "lang": {
      "en": {
        "topic": "Effects",
        "type": {
          "singleAnswer": {
            "question": "What do effects enable us to do?",
            "correctAnswer": "They provide us with a place where we can write side effects and define when that code is executed.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the primary purpose of Effects in React?",
            "correctAnswer": "To perform side effects and define when they should run.",
            "falseAnswers": [
              "To manage component state.",
              "To define the component's structure.",
              "To pass data between components."
            ]
          }
        }
      },
      "hr": {
        "topic": "efekti",
        "type": {
          "singleAnswer": {
            "question": "Šta nam omogućavaju efekti?",
            "correctAnswer": "Omogućavaju nam mjesto gdje možemo pisati nuspojave i definiramo kada se taj kod izvršava.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je primarna svrha Efekata u Reactu?",
            "correctAnswer": "Izvođenje nuspojava i definiranje kada bi se trebale pokrenuti.",
            "falseAnswers": [
              "Upravljanje stateom komponente.",
              "Definiranje strukture komponente.",
              "Prosljeđivanje podataka između komponenti."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "86",
    "lang": {
      "en": {
        "topic": "Effects",
        "type": {
          "singleAnswer": {
            "question": "What are the parameters we pass to the useEffect hook?",
            "correctAnswer": "The first is the function with the side effect we want to run. The second is the dependency array which contains values that React uses to determine when the provided function containing the side effect should be executed.",
            "isEnumeratable": true,
            "answerItems": ["Function with the side effect", "Dependency array"]
          },
          "multipleChoiceAnswer": {
            "question": "What are the two main arguments passed to the `useEffect` hook?",
            "correctAnswer": "A function containing the effect and a dependency array.",
            "falseAnswers": [
              "The component's state and props.",
              "An event handler and a cleanup function.",
              "A boolean value and a number."
            ]
          }
        }
      },
      "hr": {
        "topic": "efekti",
        "type": {
          "singleAnswer": {
            "question": "Koji su parametri koje predajemo u useEffect hook?",
            "correctAnswer": "Prvi je funkcija s nuspojavom koju hoćemo pokrenuti. Drugi je dependency array koji sadrži vrijednosti koje React koristi za određivanje kada bi trebalo pokrenuti predanu funkciju koja sadrži nuspojavu.",
            "isEnumeratable": true,
            "answerItems": ["Funkcija s nuspojavom", "Dependency array"]
          },
          "multipleChoiceAnswer": {
            "question": "Koja su dva glavna argumenta prosljeđena `useEffect` hooku?",
            "correctAnswer": "Funkcija koja sadrži efekt i dependency array.",
            "falseAnswers": [
              "State i props-ovi komponente.",
              "Event handler i cleanup funkcija.",
              "Boolean vrijednost i broj."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "87",
    "lang": {
      "en": {
        "topic": "Effects",
        "type": {
          "singleAnswer": {
            "question": "List all situations of passing the dependency array in useEffect and how it will affect its execution?",
            "correctAnswer": "1. If there is no dependency array, the provided function will execute after every render. 2. If the dependency array is empty, the provided function will execute only in the mount phase (initial render). 3. If the dependency array contains values, after every change of any value, the provided function will re-run.",
            "isEnumeratable": true,
            "answerItems": [
              "No dependency array: runs after every render",
              "Empty dependency array: runs only on mount",
              "Dependency array with values: runs on mount and when any value changes"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "When does a `useEffect` hook with an empty dependency array (`[]`) execute?",
            "correctAnswer": "Only once, after the initial render (mount).",
            "falseAnswers": [
              "After every render.",
              "Whenever any prop or state changes.",
              "Only when the component is unmounted."
            ]
          }
        }
      },
      "hr": {
        "topic": "efekti",
        "type": {
          "singleAnswer": {
            "question": "Naboroji sve situacije predanja dependency array u useEffect i kako će to utjecati na njegovo izvršavanje?",
            "correctAnswer": "1. Ako nema dependency array-a, predana će se funkcija izvršavati nakon svakog render-a. 2. Ako dependency array nema sadržaja, predana funkcija će se izvršiti samo u mount fazi (inicialnom render-u). 3. Ako dependency array sadrži vrijednosti, nakon svake promjene bilo koje vrijednosti, predana funkcija će se ponovno pokrenuti.",
            "isEnumeratable": true,
            "answerItems": [
              "Bez dependency array-a: izvršava se nakon svakog render-a",
              "Prazan dependency array: izvršava se samo pri mountu",
              "Dependency array s vrijednostima: izvršava se pri mountu i kada se promijeni bilo koja vrijednost"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Kada se izvršava `useEffect` hook s praznim dependency arrayem (`[]`)?",
            "correctAnswer": "Samo jednom, nakon početnog renderiranja (mount).",
            "falseAnswers": [
              "Nakon svakog renderiranja.",
              "Kad god se promijeni bilo koji prop ili state.",
              "Samo kada se komponenta unmounta."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "88",
    "lang": {
      "en": {
        "topic": "Effects",
        "type": {
          "singleAnswer": {
            "question": "What does useEffect return and what is its purpose?",
            "correctAnswer": "It returns a clean-up function that is used to clean up resources before the effect re-runs, or before the component unmounts (prevents memory leaks).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the purpose of the function returned by `useEffect`?",
            "correctAnswer": "To clean up resources before the effect re-runs or the component unmounts.",
            "falseAnswers": [
              "To update the component's state.",
              "To trigger a re-render of the component.",
              "To fetch data from an API."
            ]
          }
        }
      },
      "hr": {
        "topic": "efekti",
        "type": {
          "singleAnswer": {
            "question": "Šta je to što vraća useEffect i ćemu to služi?",
            "correctAnswer": "Vraća clean-up funkciju koja služi za čišćenje resursa prije ponovnog izvršavanja efekta, čišćenje resursa prije unmount-anja komponente (spriječava curenje memorije).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je svrha funkcije koju vraća `useEffect`?",
            "correctAnswer": "Čišćenje resursa prije ponovnog pokretanja efekta ili unmounta komponente.",
            "falseAnswers": [
              "Ažuriranje statea komponente.",
              "Pokretanje ponovnog renderiranja komponente.",
              "Dohvaćanje podataka s API-ja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "89",
    "lang": {
      "en": {
        "topic": "Effects",
        "type": {
          "singleAnswer": {
            "question": "As a rule, how many side effects should there be in one hook?",
            "correctAnswer": "As a rule, there should be one hook for one side effect.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the recommended practice regarding the number of side effects per `useEffect` hook?",
            "correctAnswer": "One effect per hook.",
            "falseAnswers": [
              "Multiple effects per hook are recommended.",
              "There is no recommendation.",
              "Effects should not be placed in hooks."
            ]
          }
        }
      },
      "hr": {
        "topic": "efekti",
        "type": {
          "singleAnswer": {
            "question": "U pravilu koliko bi trebalo biti nuspojava u jednom hook-u?",
            "correctAnswer": "U pravilu treba postojati jedan hook za jednu nuspojavu.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je preporučena praksa u vezi broja nuspojava po `useEffect` hooku?",
            "correctAnswer": "Jedan efekt po hooku.",
            "falseAnswers": [
              "Preporučuje se više efekata po hooku.",
              "Nema preporuke.",
              "Efekti se ne bi trebali stavljati u hookove."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "90",
    "lang": {
      "en": {
        "topic": "Side effects",
        "type": {
          "singleAnswer": {
            "question": "Where can we perform side effects in React and what triggers those places?",
            "correctAnswer": "We can perform side effects in event handlers, which are triggered by events, and in effects, which are triggered by renders.",
            "isEnumeratable": true,
            "answerItems": [
              "Event handlers (triggered by events)",
              "Effects (triggered by renders)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Where are side effects typically performed in React?",
            "correctAnswer": "In event handlers or effects.",
            "falseAnswers": [
              "Directly in the component's render logic.",
              "In the component's return statement.",
              "In the component's initial state declaration."
            ]
          }
        }
      },
      "hr": {
        "topic": "nuspojave",
        "type": {
          "singleAnswer": {
            "question": "Gdje možemo raditi nuspojave u React-u i što pokreće ta mijesta?",
            "correctAnswer": "Nuspojave možemo raditi u event handlerima, njih pokreću događajai i efektima koje pokreću renderiranja.",
            "isEnumeratable": true,
            "answerItems": [
              "event handlerima (pokreću događaji)",
              "efektima (pokreću renderiranja)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Gdje se nuspojave tipično izvode u Reactu?",
            "correctAnswer": "U event handlerima ili efektima.",
            "falseAnswers": [
              "Direktno u render logici komponente.",
              "U return izrazu komponente.",
              "U početnoj deklaraciji statea komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "91",
    "lang": {
      "en": {
        "topic": "Effects",
        "type": {
          "singleAnswer": {
            "question": "When does an effect (referring to useEffect) run relative to the rendering process and what are the implications of this?",
            "correctAnswer": "It runs after the DOM changes are displayed on the screen (after the browser paint), which means if you change state within the effect, an additional render will be needed.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "When does a `useEffect` hook execute relative to the browser painting the screen?",
            "correctAnswer": "After the browser has painted the screen.",
            "falseAnswers": [
              "Before the browser starts painting.",
              "During the browser painting process.",
              "Only when the component is unmounted."
            ]
          }
        }
      },
      "hr": {
        "topic": "efekti",
        "type": {
          "singleAnswer": {
            "question": "Kada se efekt (misli se na useEffect) pokreće u odnosu na proces renderiranja i koje su implikacije toga?",
            "correctAnswer": "Poreće se nakon prikazivanja DOM promjena na ekran (nakon browser paint-a), što znači ako mijenjamo state u efektu biti će potreban dodatni render.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kada se `useEffect` hook izvršava u odnosu na browserovo iscrtavanje ekrana?",
            "correctAnswer": "Nakon što je preglednik iscrtao ekran.",
            "falseAnswers": [
              "Prije nego što preglednik počne iscrtavati.",
              "Tijekom procesa iscrtavanja preglednika.",
              "Samo kada se komponenta unmounta."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "92",
    "lang": {
      "en": {
        "topic": "Effects",
        "type": {
          "singleAnswer": {
            "question": "What effects exist and how do they differ?",
            "correctAnswer": "1. useEffect: executes asynchronously after changes in the DOM are reflected on the screen. 2. useLayoutEffect: executes synchronously after all DOM manipulations, but before the browser paints. 3. useInsertionEffect: executes before any DOM manipulations.",
            "isEnumeratable": true,
            "answerItems": [
              "useEffect (async, after paint)",
              "useLayoutEffect (sync, before paint)",
              "useInsertionEffect (before DOM mutations)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which React effect hook executes synchronously after all DOM mutations but before the browser paints?",
            "correctAnswer": "useLayoutEffect.",
            "falseAnswers": [
              "useEffect.",
              "useInsertionEffect.",
              "useCallback."
            ]
          }
        }
      },
      "hr": {
        "topic": "efekti",
        "type": {
          "singleAnswer": {
            "question": "Koji efekti postoje i u čemu se razlikuju?",
            "correctAnswer": "1. useEffect: izvršava se asinkrono nakon što se se promijene u DOM-u već reflektirale na ekran. 2. useLayoutEffect: izvršava se sinkrono nakon svih DOM manipulacija, ali prije nego što browser napravi painting. 3. useInsertionEffect: izvršava se prije bilo kakvih DOM mainpulacija.",
            "isEnumeratable": true,
            "answerItems": [
              "useEffect (asinkrono, nakon iscrtavanja)",
              "useLayoutEffect (sinkrono, prije iscrtavanja)",
              "useInsertionEffect (prije DOM mutacija)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koji React efekt hook izvršava sinkrono nakon svih DOM mutacija, ali prije nego što preglednik iscrta?",
            "correctAnswer": "useLayoutEffect.",
            "falseAnswers": [
              "useEffect.",
              "useInsertionEffect.",
              "useCallback."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "93",
    "lang": {
      "en": {
        "topic": "React hooks",
        "type": {
          "singleAnswer": {
            "question": "What are React hooks?",
            "correctAnswer": "Built-in functions that allow us to 'hook into' internal functionalities.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What are React Hooks?",
            "correctAnswer": "Functions that let you use React features in functional components.",
            "falseAnswers": [
              "A type of component.",
              "A styling method.",
              "A routing library."
            ]
          }
        }
      },
      "hr": {
        "topic": "React hook-ovi",
        "type": {
          "singleAnswer": {
            "question": "Što su React hook-ovi?",
            "correctAnswer": "Ugrađene funkcije koje nam omogućavaju 'povezivanje' s internim funkcionalnostima.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što su React Hookovi?",
            "correctAnswer": "Funkcije koje vam omogućuju korištenje React značajki u funkcionalnim komponentama.",
            "falseAnswers": [
              "Vrsta komponente.",
              "Metoda stiliziranja.",
              "Biblioteka za rutiranje."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "94",
    "lang": {
      "en": {
        "topic": "React hooks",
        "type": {
          "singleAnswer": {
            "question": "With what word do hooks start?",
            "correctAnswer": "They start with the word 'use'.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What prefix do all standard React hooks use?",
            "correctAnswer": "use.",
            "falseAnswers": ["get.", "set.", "handle."]
          }
        }
      },
      "hr": {
        "topic": "React hook-ovi",
        "type": {
          "singleAnswer": {
            "question": "S kojom riječju započinju hook-ovi?",
            "correctAnswer": "Započinju riječi use.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koji prefiks koriste svi standardni React hookovi?",
            "correctAnswer": "use.",
            "falseAnswers": ["get.", "set.", "handle."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "95",
    "lang": {
      "en": {
        "topic": "React hooks",
        "type": {
          "singleAnswer": {
            "question": "List the most commonly used React hooks (you can also list others).",
            "correctAnswer": "useState, useEffect, useReducer, useContext (useRef, useCallback, useMemo, useTransition, useDefferredValue, useLayoutEffect, useDebugValue, useImperativeHandle, useId, useInsertionEffect, useSyncexternalStore).",
            "isEnumeratable": true,
            "answerItems": [
              "useState",
              "useEffect",
              "useReducer",
              "useContext",
              "useRef",
              "useCallback",
              "useMemo",
              "useTransition",
              "useDefferredValue",
              "useLayoutEffect",
              "useDebugValue",
              "useImperativeHandle",
              "useId",
              "useInsertionEffect",
              "useSyncexternalStore"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is a commonly used React hook?",
            "correctAnswer": "useState.",
            "falseAnswers": ["useComponent.", "useRender.", "useLogic."]
          }
        }
      },
      "hr": {
        "topic": "React hook-ovi",
        "type": {
          "singleAnswer": {
            "question": "Nabroj najčešće korišteni React hook-ove (možeš i ostale).",
            "correctAnswer": "useState, useEffect, useReducer, useContext (useRef, useCallback, useMemo, useTransition, useDefferredValue, useLayoutEffect, useDebugValue, useImperativeHandle, useId, useInsertionEffect, useSyncexternalStore).",
            "isEnumeratable": true,
            "answerItems": [
              "useState",
              "useEffect",
              "useReducer",
              "useContext",
              "useRef",
              "useCallback",
              "useMemo",
              "useTransition",
              "useDefferredValue",
              "useLayoutEffect",
              "useDebugValue",
              "useImperativeHandle",
              "useId",
              "useInsertionEffect",
              "useSyncexternalStore"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koje od sljedećih je često korišteni React hook?",
            "correctAnswer": "useState.",
            "falseAnswers": ["useComponent.", "useRender.", "useLogic."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "96",
    "lang": {
      "en": {
        "topic": "React hooks",
        "type": {
          "singleAnswer": {
            "question": "What are the rules for using hooks?",
            "correctAnswer": "1. They are called only at the top level of the code: they are not called inside conditions, loops, nested functions, or after an early return (this is important so that hooks are always executed in the same order). 2. They are called only in React functions (React functional components or custom hooks).",
            "isEnumeratable": true,
            "answerItems": [
              "Called only at the top level of the code",
              "Called only in React functions (functional components or custom hooks)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is a valid place to call a React hook?",
            "correctAnswer": "At the top level of a functional component.",
            "falseAnswers": [
              "Inside a conditional statement within a functional component.",
              "Inside a loop within a functional component.",
              "Inside a regular JavaScript function."
            ]
          }
        }
      },
      "hr": {
        "topic": "React hook-ovi",
        "type": {
          "singleAnswer": {
            "question": "Koja su pravila korištenja hook-ova?",
            "correctAnswer": "1. Pozivaju se samo na najvišoj razini koda: ne pozivaju se unutar uvjeta, petlji, ugnježđenih funkcija ili poslije ranog return-a (to je bitno da se hookovi izvršavaju uvijek istim redoslijedom). 2. Pozivaju se samo u React funkcijama (React funkciske komponente ili prilagođenim hook-ovima).",
            "isEnumeratable": true,
            "answerItems": [
              "Pozivaju se samo na najvišoj razini koda",
              "Pozivaju se samo u React funkcijama (React funkciske komponente ili prilagođenim hook-ovima)"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koje od sljedećih je valjano mjesto za pozivanje React hooka?",
            "correctAnswer": "Na najvišoj razini funkcionalne komponente.",
            "falseAnswers": [
              "Unutar uvjetnog izraza unutar funkcionalne komponente.",
              "Unutar petlje unutar funkcionalne komponente.",
              "Unutar obične JavaScript funkcije."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "97",
    "lang": {
      "en": {
        "topic": "React hooks",
        "type": {
          "singleAnswer": {
            "question": "Explain why hooks rely on the order of calls?",
            "correctAnswer": "During the initial load (rendering), a virtual DOM is created from which we get the fiber tree. The fiber tree consists of Fiber elements that represent an instance of a DOM element. In that fiber, one of the things stored is a linked list of all hooks called in that component (from which the DOM instance was created). So, if a hook from that linked list is no longer there (e.g., when a re-render occurs), i.e., it is no longer called in the new render, the reference to the next hook is lost, and thus to all subsequent hooks. That's why it's important that hooks are always called in the same order and are not in places where their call order could be mixed up or not called at all (first and second rule of hooks).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Why is the order of hook calls important in React?",
            "correctAnswer": "React relies on the consistent order of hook calls to associate state and effects with the correct component instance.",
            "falseAnswers": [
              "It affects the performance of the application.",
              "It determines the order in which components are rendered.",
              "It is necessary for prop validation."
            ]
          }
        }
      }
    },
    "hr": {
      "topic": "React hook-ovi",
      "type": {
        "singleAnswer": {
          "question": "Objasni zašto se hook-ovi oslanjaju na redoslijed poziva?",
          "correctAnswer": "Pri inicialnom učitavanju (renderiranju) se stvara virtualni DOM iz kojega dobivamo fiber stablo. Fiber stablo se sastoji od Fiber elemenata koji predstavljaju instancu DOM elementa. U tom fiber-u jedna od stvari koja je spremljena je povezana lista svih hook-ova pozvanih u toj komponenti (iz koje je nastala DOM instanca). Tako da ako se jedan hook iz te povezane liste više ne nalazi tamo (npr. kada se pokrene re-render), odnosno ne poziva se više u novom renderu. Tada se gubi referenca na idući hook, pa tako i na sve hook-ove poslije njega. Zato je bitno da hook-ovi budu pozvani uvijek istim redoslijedom i da nisu na mjestima gdje bi se mogli pobrkati njihov redoslijed poziva ili da se uopće ne pozovu (prvo i drugo pravilo hook-ova).",
          "isEnumeratable": false,
          "answerItems": []
        },
        "multipleChoiceAnswer": {
          "question": "Zašto je redoslijed poziva hookova važan u Reactu?",
          "correctAnswer": "React se oslanja na dosljedan redoslijed poziva hookova kako bi povezao state i efekte s ispravnom instancom komponente.",
          "falseAnswers": [
            "Utječe na performanse aplikacije.",
            "Određuje redoslijed renderiranja komponenti.",
            "Potrebno je za validaciju props-ova."
          ]
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "98",
    "lang": {
      "en": {
        "topic": "React hooks",
        "type": {
          "singleAnswer": {
            "question": "Why, when a hook is not called (and was called in the initial rendering) in a re-render, is the linked list of hooks in that fiber, within the fiber tree, destroyed?",
            "correctAnswer": "The fiber tree is created only on the initial load of our application and is then only changed throughout the application's life. So, once a linked list of hooks is created for a specific fiber, it cannot be reconstructed. Therefore, it's important that all hooks are always in it throughout all renders. Because if a hook were removed from that list, the reference to all subsequent elements would be lost (because that's how a linked list works, an element remembers the reference of the next element in the list), and it's impossible to reconstruct that list (because the fiber tree is built only once).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What happens internally if a hook is skipped during a re-render after being called in the initial render?",
            "correctAnswer": "React loses track of the state and effects associated with that component instance.",
            "falseAnswers": [
              "The component will throw a syntax error.",
              "The skipped hook's state will be reset to its initial value.",
              "React will automatically adjust the order of the remaining hooks."
            ]
          }
        }
      },
      "hr": {
        "topic": "React hook-ovi",
        "type": {
          "singleAnswer": {
            "question": "Zašto kada se neki hook ne pozove (a bio je pozvan u inicialnom renderiranju) u re-renderu uništi povezanu listu hook-ova u tom fiber-u, unutar fiber stabla?",
            "correctAnswer": "Fiber stablo se stvara samo pri inicijalnom učitavanju naše aplikacije i onda se samo mijenja kroz životni vijek aplikacije. Tako da kada se jednom napravi povezana lista hook-ova za pojedini fiber, više se ne može ponovno konstruirati pa je bitno da uvijek svi hook-ovi budu u njoj kroz sve render-e. Jer kada bi neki hook-bio maknut iz te liste izgubila bi se referenca na sve iduće elemente (jer tako radi povezana lista, element pamti referencu idućeg elementa u nizu), a nemoguće je ponovno konstruirati taj niz (jer se fiber stablo samo jednom izgrađuje).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što se događa interno ako se hook preskoči tijekom ponovnog renderiranja nakon što je pozvan u početnom renderiranju?",
            "correctAnswer": "React gubi trag o stateu i efektima povezanim s tom instancom komponente.",
            "falseAnswers": [
              "Komponenta će baciti sintaksnu grešku.",
              "State preskočenog hooka bit će resetiran na početnu vrijednost.",
              "React će automatski prilagoditi redoslijed preostalih hookova."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "99",
    "lang": {
      "en": {
        "topic": "useRef",
        "type": {
          "singleAnswer": {
            "question": "What is useRef and what does it enable us to do?",
            "correctAnswer": "An object with a mutable .current property that remains the same across renders. It allows us to create variables that persist across different renders and select and store DOM elements.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the primary purpose of the `useRef` hook?",
            "correctAnswer": "To create a mutable value that persists across renders without causing re-renders.",
            "falseAnswers": [
              "To manage component state.",
              "To perform side effects.",
              "To fetch data from an API."
            ]
          }
        }
      },
      "hr": {
        "topic": "useRef",
        "type": {
          "singleAnswer": {
            "question": "Što je useRef i šta nam on omogućuje?",
            "correctAnswer": "Objekt s promijenjivim .current svojstvom koje ostaje isto kroz rendere. Omogućuje nam kreiranje varijabli koje ostaju iste kroz različite rendere i selektiranje i spremanje DOM elemenata.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je primarna svrha `useRef` hooka?",
            "correctAnswer": "Kreiranje promjenjive vrijednosti koja ostaje ista kroz rendere bez uzrokovanja ponovnog renderiranja.",
            "falseAnswers": [
              "Upravljanje stateom komponente.",
              "Izvođenje nuspojava.",
              "Dohvaćanje podataka s API-ja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "100",
    "lang": {
      "en": {
        "topic": "useRef",
        "type": {
          "singleAnswer": {
            "question": "What kind of data are refs for and what is the rule for them?",
            "correctAnswer": "They are for data that is not displayed (in the render logic). As a rule, you should not write to or read the .current property in render logic (you should use state for that).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "When should you primarily use a `useRef` hook?",
            "correctAnswer": "For storing values that don't need to trigger a re-render when they change.",
            "falseAnswers": [
              "For managing data that directly affects the component's output.",
              "For performing side effects like data fetching.",
              "For defining the initial state of a component."
            ]
          }
        }
      },
      "hr": {
        "topic": "useRef",
        "type": {
          "singleAnswer": {
            "question": "Za koje podatke služe refovi i koje je pravilo za njih?",
            "correctAnswer": "Služe za podatke koji se ne prikazuju (u render logici). U pravilu, ne bi smijeli pisati ili čitati .current svojstvo u render logici (za to bi se trebalo koristiti state).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kada biste prvenstveno trebali koristiti `useRef` hook?",
            "correctAnswer": "Za pohranu vrijednosti koje ne trebaju pokrenuti ponovno renderiranje kada se promijene.",
            "falseAnswers": [
              "Za upravljanje podacima koji direktno utječu na izlaz komponente.",
              "Za izvođenje nuspojava poput dohvaćanja podataka.",
              "Za definiranje početnog statea komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "101",
    "lang": {
      "en": {
        "topic": "useRef",
        "type": {
          "singleAnswer": {
            "question": "What is the difference between ref and state?",
            "correctAnswer": "Changing a ref does not cause a re-render.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a key difference between `useRef` and `useState`?",
            "correctAnswer": "Updating a ref does not trigger a re-render, while updating state does.",
            "falseAnswers": [
              "Refs are used for managing UI, while state is for business logic.",
              "State persists across renders, while refs do not.",
              "Refs can only store primitive values, while state can store objects."
            ]
          }
        }
      },
      "hr": {
        "topic": "useRef",
        "type": {
          "singleAnswer": {
            "question": "Koja je razlika između ref-a i state-a?",
            "correctAnswer": "Promijenom ref se ne događa re-render.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je ključna razlika između `useRef` i `useState`?",
            "correctAnswer": "Ažuriranje refa ne pokreće ponovno renderiranje, dok ažuriranje statea pokreće.",
            "falseAnswers": [
              "Refovi se koriste za upravljanje UI-jem, dok je state za poslovnu logiku.",
              "State ostaje isti kroz rendere, dok refovi ne.",
              "Refovi mogu pohraniti samo primitivne vrijednosti, dok state može pohraniti objekte."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "102",
    "lang": {
      "en": {
        "topic": "Custom hook",
        "type": {
          "singleAnswer": {
            "question": "What is a custom hook?",
            "correctAnswer": "A function that allows us to reuse non-visual logic in different components and uses one or more other hooks.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a custom React hook?",
            "correctAnswer": "A JavaScript function that uses other hooks to share reusable logic between components.",
            "falseAnswers": [
              "A special type of component that can manage global state.",
              "A built-in React hook for performing side effects.",
              "A method for styling components."
            ]
          }
        }
      },
      "hr": {
        "topic": "prilagođeni hook",
        "type": {
          "singleAnswer": {
            "question": "Što je to custom hook?",
            "correctAnswer": "Funkcija koja nam omogućuje da ponovno koristimo nevizalnu logiku u različitim komponentama, a koristi jedan ili više drugih hook-ova.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je custom React hook?",
            "correctAnswer": "JavaScript funkcija koja koristi druge hookove za dijeljenje logike između komponenti.",
            "falseAnswers": [
              "Posebna vrsta komponente koja može upravljati globalnim stateom.",
              "Ugrađeni React hook za izvođenje nuspojava.",
              "Metoda za stiliziranje komponenti."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "103",
    "lang": {
      "en": {
        "topic": "Custom hooks",
        "type": {
          "singleAnswer": {
            "question": "What is the unwritten rule for custom hooks and how should we name them?",
            "correctAnswer": "One custom hook should have one purpose, and the name should start with 'use' just like other hooks.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is a convention for naming custom React hooks?",
            "correctAnswer": "Their name should start with `use`.",
            "falseAnswers": [
              "Their name should be in camelCase.",
              "Their name should be in PascalCase.",
              "Their name should be all lowercase."
            ]
          }
        }
      },
      "hr": {
        "topic": "prilagođeni hook-ovi",
        "type": {
          "singleAnswer": {
            "question": "Koje je nepisano pravilo za custom hook-ove i kako ih trebamo imenovati?",
            "correctAnswer": "Jedan cusom hook treba imati jednu svrhu i ime treba započinjati sa use kao i kod ostali hook-ova.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je konvencija za imenovanje custom React hookova?",
            "correctAnswer": "Njihovo ime treba započinjati s `use`.",
            "falseAnswers": [
              "Njihovo ime treba biti u camelCase formatu.",
              "Njihovo ime treba biti u PascalCase formatu.",
              "Njihovo ime treba biti sva mala slova."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "104",
    "lang": {
      "en": {
        "topic": "useReducer",
        "type": {
          "singleAnswer": {
            "question": "What is useReducer?",
            "correctAnswer": "A hook that allows us to manage state in a more complex way than the useState hook.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the primary purpose of the `useReducer` hook?",
            "correctAnswer": "To manage complex state logic.",
            "falseAnswers": [
              "To perform side effects.",
              "To fetch data from an API.",
              "To optimize component rendering."
            ]
          }
        }
      },
      "hr": {
        "topic": "useReducer",
        "type": {
          "singleAnswer": {
            "question": "Što je useReducer?",
            "correctAnswer": "Hook koji nam omogućava upravljanje state-om na kompleksniji način nego useState hook.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je primarna svrha `useReducer` hooka?",
            "correctAnswer": "Upravljanje složenom state logikom.",
            "falseAnswers": [
              "Izvođenje nuspojava.",
              "Dohvaćanje podataka s API-ja.",
              "Optimizacija renderiranja komponente."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "105",
    "lang": {
      "en": {
        "topic": "useReducer",
        "type": {
          "singleAnswer": {
            "question": "When is useReducer suitable for use?",
            "correctAnswer": "When we want to update multiple states at once, when we need to update state that depends on other states, when we want to have a complex value (object) as state.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "When is `useReducer` particularly useful?",
            "correctAnswer": "For managing state with complex update logic or when multiple state variables depend on each other.",
            "falseAnswers": [
              "For simple state updates.",
              "For performing side effects.",
              "For fetching data from an API."
            ]
          }
        }
      },
      "hr": {
        "topic": "useReducer",
        "type": {
          "singleAnswer": {
            "question": "Kada je useReducer pogodan za korištenje?",
            "correctAnswer": "Kada hoćemo ažurirati više state-a odjednom, kada trebamo ažurirati state koji ovisi o drugim state-ovim, kada hoćemo kao state imati kompleksnu prijednost (objekt).",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Kada je `useReducer` posebno koristan?",
            "correctAnswer": "Za upravljanje stateom sa složenom logikom ažuriranja ili kada više varijabli statea ovisi jedna o drugoj.",
            "falseAnswers": [
              "Za jednostavna ažuriranja statea.",
              "Za izvođenje nuspojava.",
              "Za dohvaćanje podataka s API-ja."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "106",
    "lang": {
      "en": {
        "topic": "Memoization",
        "type": {
          "singleAnswer": {
            "question": "In what ways can we improve performance in React applications?",
            "correctAnswer": "1. Preventing unnecessary renders (renders that do not cause any visual changes). 2. Improving application speed/responsiveness. 3. Reducing bundle size.",
            "isEnumeratable": true,
            "answerItems": [
              "Preventing unnecessary renders",
              "Improving speed/responsiveness",
              "Reducing bundle size"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which of the following is a way to improve performance in React applications?",
            "correctAnswer": "Preventing unnecessary re-renders.",
            "falseAnswers": [
              "Increasing the number of state updates.",
              "Using more complex component structures.",
              "Directly manipulating the DOM."
            ]
          }
        }
      },
      "hr": {
        "topic": "memoizacija",
        "type": {
          "singleAnswer": {
            "question": "Na koje sve načine možemo poboljšati performanse u React aplikacijama?",
            "correctAnswer": "1. Spriječavanje nepotrebnih renderiranja (renderiranja koja ne prouzrokuju nikakve vizualne promijene), 2. Poboljšanje brzine/responzivnosti aplikacije, 3. Smanjenje veličine bundle-a.",
            "isEnumeratable": true,
            "answerItems": [
              "Spriječavanje nepotrebnih renderiranja",
              "Poboljšanje brzine/responzivnosti",
              "Smanjenje veličine bundle-a"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koje od sljedećih je način poboljšanja performansi u React aplikacijama?",
            "correctAnswer": "Spriječavanje nepotrebnih ponovnih renderiranja.",
            "falseAnswers": [
              "Povećanje broja ažuriranja statea.",
              "Korištenje složenijih struktura komponenti.",
              "Direktno manipuliranje DOM-om."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "107",
    "lang": {
      "en": {
        "topic": "Memoization",
        "type": {
          "singleAnswer": {
            "question": "What is memoization in the context of React?",
            "correctAnswer": "An optimization technique that executes a pure function (e.g., a component) once and stores the result in memory (cache). If we try to execute the same function again with the same arguments as before, the previously stored result will be returned without re-executing the function.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is memoization in React?",
            "correctAnswer": "Caching the result of a function or component to avoid re-calculation on subsequent renders with the same inputs.",
            "falseAnswers": [
              "A method for managing component state.",
              "A technique for handling asynchronous operations.",
              "A way to define reusable components."
            ]
          }
        }
      },
      "hr": {
        "topic": "memoizacija",
        "type": {
          "singleAnswer": {
            "question": "Što je to memoizacija u kontekstu React-a?",
            "correctAnswer": "Tehnika optimiziranja koja izvršava neku čistu funkciju (npr. komponentu) jednom i sprema rezultat u memoriju (cache). Ako pokušamo izvršiti istu funkciju ponovno sa istim argumentima kao i prije, biti će vraćen prethodno spremljeni rezultat bez ponovnog izvršavanja funkcije.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Što je memoizacija u Reactu?",
            "correctAnswer": "Keširanje rezultata funkcije ili komponente kako bi se izbjeglo ponovno izračunavanje pri sljedećim renderima s istim ulazima.",
            "falseAnswers": [
              "Metoda za upravljanje stateom komponente.",
              "Tehnika za rukovanje asinkronim operacijama.",
              "Način definiranja komponenti za ponovnu upotrebu."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "108",
    "lang": {
      "en": {
        "topic": "Memoization",
        "type": {
          "singleAnswer": {
            "question": "What things can we memoize and using what?",
            "correctAnswer": "We can memoize components with the `memo` function, objects with the `useMemo` function, and functions with the `useCallback` function.",
            "isEnumeratable": true,
            "answerItems": [
              "Components with `memo`",
              "Objects with `useMemo`",
              "Functions with `useCallback`"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which hook is used to memoize functions in React?",
            "correctAnswer": "useCallback.",
            "falseAnswers": ["useMemo.", "useEffect.", "useState."]
          }
        }
      },
      "hr": {
        "topic": "memoizacija",
        "type": {
          "singleAnswer": {
            "question": "Koje sve stvari možemo memoizirati i pomoću čega?",
            "correctAnswer": "Možemo memoizirati komponente s funkcijom memo, objekte s funkcijom useMemo i funkcije s funkcijom useCallback.",
            "isEnumeratable": true,
            "answerItems": [
              "Komponente s funkcijom `memo`",
              "Objekte s funkcijom `useMemo`",
              "Funkcije s funkcijom `useCallback`"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koji hook se koristi za memoizaciju funkcija u Reactu?",
            "correctAnswer": "useCallback.",
            "falseAnswers": ["useMemo.", "useEffect.", "useState."]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "109",
    "lang": {
      "en": {
        "topic": "Memoization",
        "type": {
          "singleAnswer": {
            "question": "What does `memo` specifically enable us to do (for components) and when should we use it?",
            "correctAnswer": "It allows the component (that we memoize) not to re-render every time its parent re-renders, as long as the props are the same. We should only use `memo` on 'heavy' components that re-render frequently with the same props.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the primary benefit of using `React.memo()` around a component?",
            "correctAnswer": "It prevents the component from re-rendering if its props haven't changed.",
            "falseAnswers": [
              "It optimizes the initial render time.",
              "It allows the component to manage its own state.",
              "It enables the component to perform side effects."
            ]
          }
        }
      },
      "hr": {
        "topic": "memoizacija",
        "type": {
          "singleAnswer": {
            "question": "Šta nam memo konkretno omogućava (kod komponenti) i kada je trebamo koristiti?",
            "correctAnswer": "Omogućava nam da se ta komponenta (koju memoiziramo) ne re-renderira svaki puta kada i njen roditelj sve dok su props-ovi isti. Memo trebamo koristiti samo na'teškim' komponentama koje se re-renderiraju često i istim props-ovima.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je primarna prednost korištenja `React.memo()` oko komponente?",
            "correctAnswer": "Sprječava ponovno renderiranje komponente ako se njeni props-ovi nisu promijenili.",
            "falseAnswers": [
              "Optimizira početno vrijeme renderiranja.",
              "Omogućuje komponenti da upravlja svojim stateom.",
              "Omogućuje komponenti da izvodi nuspojave."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "110",
    "lang": {
      "en": {
        "topic": "Memoization",
        "type": {
          "singleAnswer": {
            "question": "What is the problem when using `memo` on a component that receives an object or function through props?",
            "correctAnswer": "Every re-render recreates all functions and objects. Functions or objects that look the same are not the same ({} !== {}) because their value is considered based on their reference in the heap. Therefore, if our component receives a function or object as a prop, `memo` is useless because every re-render that object or function will be seen as a new value, even though they look the same (objects have the same property values, and functions do the same thing), and thus the component will always re-render when its parent does.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Why can `React.memo()` be ineffective for components receiving objects or functions as props?",
            "correctAnswer": "Objects and functions are recreated on every render, leading to new references even if their content is the same.",
            "falseAnswers": [
              "Memoization only works with primitive prop types.",
              "Objects and functions cannot be passed as props.",
              "Memoization causes performance issues with complex prop types."
            ]
          }
        }
      },
      "hr": {
        "topic": "memoizacija",
        "type": {
          "singleAnswer": {
            "question": "Koje je problem kod korištenja memo nad komponentom koja prima objekt ili funkciju kroz props-ove?",
            "correctAnswer": "Pri svakom re-renderiraju se ponovno kreiraju sve funkcije i objekti. A funkcije ili objekt koji isto izgledaju nisu isti ({} !== {}) jer se kao vrijednost gleda njihova referenca gdje se oni nalaze na heap-u. Pa samim time ako kao prop naša komponenta prima funkciju ili objekt, memo nam ništa ne znači  jer će se svaki re-render taj objekt ili funkcija gledati kao nova vrijednost, premda same po sebi isto izgledaju (objekti imaju iste vrijednosti svojih svojstava, a funkcije rade istu stvar) i samim time komponenta će se uvijek re-renderat kad i roditelj.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Zašto `React.memo()` može biti neučinkovit za komponente koje primaju objekte ili funkcije kao props-ove?",
            "correctAnswer": "Objekti i funkcije se ponovno kreiraju pri svakom renderu, što dovodi do novih referenci čak i ako je njihov sadržaj isti.",
            "falseAnswers": [
              "Memoizacija radi samo s primitivnim tipovima props-ova.",
              "Objekti i funkcije se ne mogu prosljeđivati kao props-ovi.",
              "Memoizacija uzrokuje probleme s performansama kod složenih tipova props-ova."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "111",
    "lang": {
      "en": {
        "topic": "Memoization",
        "type": {
          "singleAnswer": {
            "question": "How do we solve the problem when using `memo` on components that receive an object or function through props?",
            "correctAnswer": "By using `useMemo` for memoizing objects and `useCallback` for memoizing functions. They ensure that the value of the object depends on the values of that object's parameters, and the value of the function depends on the parameters that function receives. So, with every new re-render, the component will not change if the values of the object themselves haven't changed or the function's parameters haven't changed.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Which hooks are used to memoize objects and functions passed as props to `React.memo()` components?",
            "correctAnswer": "useMemo for objects and useCallback for functions.",
            "falseAnswers": [
              "useEffect for objects and useState for functions.",
              "useRef for objects and useReducer for functions.",
              "useContext for objects and useTransition for functions."
            ]
          }
        }
      },
      "hr": {
        "topic": "memoizacija",
        "type": {
          "singleAnswer": {
            "question": "Kako riješavamo problem kod korištenja memo nad komponentama koje primaju objekt ili funkciju kroz props-ove?",
            "correctAnswer": "Korištenjem useMemo za memoizaciju objekata i useCallback za memoizaciju funkcija. Oni omogućavaju da vrijednost objekta ovisi o vrijednostima parametara tog objekta, a da vrijednost funkcije ovisi o parametrima koje ta funkcija prima. Tako da pri svakom novom re-renderu se komponenta neće promijeniti ako se same vrijednosti objekta nisu promijenili ili parametri funkcije.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koji se hookovi koriste za memoizaciju objekata i funkcija prosljeđenih kao props-ovi komponentama omotanim s `React.memo()`?",
            "correctAnswer": "useMemo za objekte i useCallback za funkcije.",
            "falseAnswers": [
              "useEffect za objekte i useState za funkcije.",
              "useRef za objekte i useReducer za funkcije.",
              "useContext za objekte i useTransition za funkcije."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  },
  {
    "id": "112",
    "lang": {
      "en": {
        "topic": "Memoization",
        "type": {
          "singleAnswer": {
            "question": "What does the dependency array mean in useMemo and useCallback?",
            "correctAnswer": "If a value in the dependency array changes, that value will be recreated and stored in memory.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "What is the purpose of the dependency array in `useMemo` and `useCallback`?",
            "correctAnswer": "To specify when the memoized value or function should be recalculated.",
            "falseAnswers": [
              "To define the initial value of the memoized item.",
              "To prevent the memoized item from changing.",
              "To store the result of the memoized function."
            ]
          }
        }
      },
      "hr": {
        "topic": "memoizacija",
        "type": {
          "singleAnswer": {
            "question": "Šta znači dependency array u useMemo i useCallback-u?",
            "correctAnswer": "Ako se neka vrijednost promijeni u dependency array-u, ponovno će se kreirati ta vrijednost i spremit će se u memoriju.",
            "isEnumeratable": false,
            "answerItems": []
          },
          "multipleChoiceAnswer": {
            "question": "Koja je svrha dependency arraya u `useMemo` i `useCallback`?",
            "correctAnswer": "Određivanje kada bi se memoizirana vrijednost ili funkcija trebala ponovno izračunati.",
            "falseAnswers": [
              "Definiranje početne vrijednosti memoizirane stavke.",
              "Sprječavanje promjene memoizirane stavke.",
              "Pohrana rezultata memoizirane funkcije."
            ]
          }
        }
      }
    },

    "has_been_drawn": false
  },
  {
    "id": "113",
    "lang": {
      "en": {
        "topic": "Memoization",
        "type": {
          "singleAnswer": {
            "question": "In what situations do we use useMemo and useCallback?",
            "correctAnswer": "1. Memoizing props to prevent unnecessary renders. 2. Memoizing values to avoid heavy recalculations on every render. 3. Memoizing values used in the dependency array of a hook (to prevent infinite rendering loops).",
            "isEnumeratable": true,
            "answerItems": [
              "Memoizing props to prevent unnecessary renders",
              "Memoizing values to avoid heavy recalculations",
              "Memoizing values used in dependency arrays of hooks"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Which situation is a good use case for `useMemo` or `useCallback`?",
            "correctAnswer": "Memoizing a complex calculation that is performed on every render.",
            "falseAnswers": [
              "Managing simple component state.",
              "Performing side effects like data fetching.",
              "Defining the initial value of a state variable."
            ]
          }
        }
      },
      "hr": {
        "topic": "memoizacija",
        "type": {
          "singleAnswer": {
            "question": "U kojim situaijama koristimo useMemo i useCallback?",
            "correctAnswer": "1. Memoiziranje props-ova da se spriječi nepotrebna renderiranja, 2. Memoiziranje vrijednosti da se izbjegne teške rekalkulacije na svakom renderiranju, 3. Memoiziranje vrijednosti koje se koriste u dependency array-u nekog hook-a (da bi se spriječila beskonačna petlja pri renderiranju).",
            "isEnumeratable": true,
            "answerItems": [
              "Memoiziranje props-ova za sprječavanje nepotrebnih renderiranja",
              "Memoiziranje vrijednosti za izbjegavanje teških rekalkulacija",
              "Memoiziranje vrijednosti koje se koriste u dependency array-ima hookova"
            ]
          },
          "multipleChoiceAnswer": {
            "question": "Koja je situacija dobar primjer upotrebe `useMemo` ili `useCallback`?",
            "correctAnswer": "Memoizacija složenog izračuna koji se izvodi pri svakom renderu.",
            "falseAnswers": [
              "Upravljanje jednostavnim stateom komponente.",
              "Izvođenje nuspojava poput dohvaćanja podataka.",
              "Definiranje početne vrijednosti varijable statea."
            ]
          }
        }
      }
    },
    "has_been_drawn": false
  }
]
